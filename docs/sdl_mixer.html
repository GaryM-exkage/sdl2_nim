<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>sdl_mixer</title>
<link rel="stylesheet" type="text/css" href="nimdoc.out.css">

<script type="text/javascript" src="dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }

  const toggleSwitch = document.querySelector('.theme-switch input[type="checkbox"]');
  function switchTheme(e) {
      if (e.target.checked) {
          document.documentElement.setAttribute('data-theme', 'dark');
          localStorage.setItem('theme', 'dark');
      } else {
          document.documentElement.setAttribute('data-theme', 'light');
          localStorage.setItem('theme', 'light');
      }
  }

  toggleSwitch.addEventListener('change', switchTheme, false);

  const currentTheme = localStorage.getItem('theme') ? localStorage.getItem('theme') : null;
  if (currentTheme) {
    document.documentElement.setAttribute('data-theme', currentTheme);

    if (currentTheme === 'dark') {
      toggleSwitch.checked = true;
    }
  }
}

window.addEventListener('DOMContentLoaded', main);
</script>

</head>
<body>
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">sdl_mixer</h1>
    <div class="row">
  <div class="three columns">
  <div class="theme-switch-wrapper">
    <label class="theme-switch" for="checkbox">
      <input type="checkbox" id="checkbox" />
      <div class="slider round"></div>
    </label>
    &nbsp;&nbsp;&nbsp; <em>Dark Mode</em>
  </div>
  <div id="global-links">
    <ul class="simple">
    <li>
      <a href="index.html">Index</a>
    </li>
    </ul>
  </div>
  <div id="searchInputDiv">
    Search: <input type="text" id="searchInput"
      onkeyup="search()" />
  </div>
  <div>
    Group by:
    <select onchange="groupBy(this.value)">
      <option value="section">Section</option>
      <option value="type">Type</option>
    </select>
  </div>
  <ul class="simple simple-toc" id="toc-list">
<li><a class="reference" id="sdl-mixerdotnim_toc" href="#sdl-mixerdotnim">sdl_mixer.nim</a></li>
<li><a class="reference" id="conflicts_toc" href="#conflicts">Conflicts</a></li>
<li>
  <a class="reference reference-toplevel" href="#7" id="57">Types</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#Chunk"
    title="Chunk* = ptr ChunkObj">Chunk</a></li>
  <li><a class="reference" href="#ChunkObj"
    title="ChunkObj* = object
  allocated*: cint ## a boolean indicating whether to free abuf when the chunk is freed.
                   ## 
                   ## `0` if the memory was not allocated and thus not owned by this chunk.
                   ## 
                   ## `1` if the memory was allocated and is thus owned by this chunk.
  abuf*: ptr uint8           ## Pointer to the sample data,
                             ## which is in the output format and sample rate.
  alen*: uint32              ## Length of abuf in bytes.
  volume*: uint8             ## Per-sample volume,
                             ## `0` = silent, `128` = max volume. This takes effect when mixing.">ChunkObj</a></li>
  <li><a class="reference" href="#Fading"
    title="Fading* {.size: sizeof(cint).} = enum
  NO_FADING, FADING_OUT, FADING_IN">Fading</a></li>
  <li><a class="reference" href="#MusicType"
    title="MusicType* {.size: sizeof(cint).} = enum
  MUS_NONE, MUS_CMD, MUS_WAV, MUS_MOD, MUS_MID, MUS_OGG, MUS_MP3,
  MUS_MP3_MAD_UNUSED, MUS_FLAC, MUS_MODPLUG_UNUSED, MUS_OPUS">MusicType</a></li>
  <li><a class="reference" href="#Music"
    title="Music* = pointer">Music</a></li>
  <li><a class="reference" href="#EffectFunc_t"
    title="EffectFunc_t* = proc (chan: cint; stream: pointer; len: cint; udata: pointer) {.
    cdecl.}">EffectFunc_t</a></li>
  <li><a class="reference" href="#EffectDone_t"
    title="EffectDone_t* = proc (chan: cint; udata: pointer) {.cdecl.}">EffectDone_t</a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#10" id="60">Consts</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#MAJOR_VERSION"
    title="MAJOR_VERSION* = 2">MAJOR_VERSION</a></li>
  <li><a class="reference" href="#MINOR_VERSION"
    title="MINOR_VERSION* = 0">MINOR_VERSION</a></li>
  <li><a class="reference" href="#PATCHLEVEL"
    title="PATCHLEVEL* = 4">PATCHLEVEL</a></li>
  <li><a class="reference" href="#COMPILEDVERSION"
    title="COMPILEDVERSION* = versionNum(MAJOR_VERSION, MINOR_VERSION, PATCHLEVEL)">COMPILEDVERSION</a></li>
  <li><a class="reference" href="#INIT_FLAC"
    title="INIT_FLAC* = 0x00000001">INIT_FLAC</a></li>
  <li><a class="reference" href="#INIT_MOD"
    title="INIT_MOD* = 0x00000002">INIT_MOD</a></li>
  <li><a class="reference" href="#INIT_MODPLUG"
    title="INIT_MODPLUG* {.deprecated.} = 0x00000004">INIT_MODPLUG</a></li>
  <li><a class="reference" href="#INIT_MP3"
    title="INIT_MP3* = 0x00000008">INIT_MP3</a></li>
  <li><a class="reference" href="#INIT_OGG"
    title="INIT_OGG* = 0x00000010">INIT_OGG</a></li>
  <li><a class="reference" href="#INIT_MID"
    title="INIT_MID* = 0x00000020">INIT_MID</a></li>
  <li><a class="reference" href="#INIT_OPUS"
    title="INIT_OPUS* = 0x00000040">INIT_OPUS</a></li>
  <li><a class="reference" href="#CHANNELS"
    title="CHANNELS* = 8">CHANNELS</a></li>
  <li><a class="reference" href="#DEFAULT_FREQUENCY"
    title="DEFAULT_FREQUENCY* = 22050">DEFAULT_FREQUENCY</a></li>
  <li><a class="reference" href="#DEFAULT_FORMAT"
    title="DEFAULT_FORMAT* = AUDIO_S16LSB">DEFAULT_FORMAT</a></li>
  <li><a class="reference" href="#DEFAULT_CHANNELS"
    title="DEFAULT_CHANNELS* = 2">DEFAULT_CHANNELS</a></li>
  <li><a class="reference" href="#MAX_VOLUME"
    title="MAX_VOLUME* = MIX_MAXVOLUME">MAX_VOLUME</a></li>
  <li><a class="reference" href="#CHANNEL_POST"
    title="CHANNEL_POST* = -2">CHANNEL_POST</a></li>
  <li><a class="reference" href="#EFFECTSMAXSPEED"
    title="EFFECTSMAXSPEED* = &quot;MIX_EFFECTSMAXSPEED&quot;">EFFECTSMAXSPEED</a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#12" id="62">Procs</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#linkedVersion"
    title="linkedVersion*(): ptr Version">linkedVersion</a></li>
  <li><a class="reference" href="#init%2Ccint"
    title="init*(flags: cint): cint">init</a></li>
  <li><a class="reference" href="#quit"
    title="quit*()">quit</a></li>
  <li><a class="reference" href="#openAudio%2Ccint%2Cuint16%2Ccint%2Ccint"
    title="openAudio*(frequency: cint; format: uint16; channels: cint; chunksize: cint): cint">openAudio</a></li>
  <li><a class="reference" href="#openAudioDevice%2Ccint%2Cuint16%2Ccint%2Ccint%2Ccstring%2Ccint"
    title="openAudioDevice*(frequency: cint; format: uint16; channels: cint;
                 chunksize: cint; device: cstring; allowed_changes: cint): cint">openAudioDevice</a></li>
  <li><a class="reference" href="#allocateChannels%2Ccint"
    title="allocateChannels*(numchans: cint): cint">allocateChannels</a></li>
  <li><a class="reference" href="#querySpec%2Cptr.cint%2Cptr.uint16%2Cptr.cint"
    title="querySpec*(frequency: ptr cint; format: ptr uint16; channels: ptr cint): cint">querySpec</a></li>
  <li><a class="reference" href="#loadWAV_RW%2Cptr.RWops%2Ccint"
    title="loadWAV_RW*(src: ptr RWops; freesrc: cint): Chunk">loadWAV_RW</a></li>
  <li><a class="reference" href="#loadMUS%2Ccstring"
    title="loadMUS*(file: cstring): Music">loadMUS</a></li>
  <li><a class="reference" href="#loadMUS_RW%2Cptr.RWops%2Ccint"
    title="loadMUS_RW*(src: ptr RWops; freesrc: cint): Music">loadMUS_RW</a></li>
  <li><a class="reference" href="#loadMUSType_RW%2Cptr.RWops%2CMusicType%2Ccint"
    title="loadMUSType_RW*(src: ptr RWops; kind: MusicType; freesrc: cint): Music">loadMUSType_RW</a></li>
  <li><a class="reference" href="#quickLoad_WAV%2Cptr.uint8"
    title="quickLoad_WAV*(mem: ptr uint8): Chunk">quickLoad_WAV</a></li>
  <li><a class="reference" href="#quickLoad_RAW%2Cptr.uint8%2Cuint32"
    title="quickLoad_RAW*(mem: ptr uint8; len: uint32): Chunk">quickLoad_RAW</a></li>
  <li><a class="reference" href="#freeChunk%2CChunk"
    title="freeChunk*(chunk: Chunk)">freeChunk</a></li>
  <li><a class="reference" href="#freeMusic%2CMusic"
    title="freeMusic*(music: Music)">freeMusic</a></li>
  <li><a class="reference" href="#getNumChunkDecoders"
    title="getNumChunkDecoders*(): cint">getNumChunkDecoders</a></li>
  <li><a class="reference" href="#getChunkDecoder%2Ccint"
    title="getChunkDecoder*(index: cint): cstring">getChunkDecoder</a></li>
  <li><a class="reference" href="#hasChunkDecoder%2Ccstring"
    title="hasChunkDecoder*(name: cstring): bool">hasChunkDecoder</a></li>
  <li><a class="reference" href="#getNumMusicDecoders"
    title="getNumMusicDecoders*(): cint">getNumMusicDecoders</a></li>
  <li><a class="reference" href="#getMusicDecoder%2Ccint"
    title="getMusicDecoder*(index: cint): cstring">getMusicDecoder</a></li>
  <li><a class="reference" href="#getMusicType%2CMusic"
    title="getMusicType*(music: Music): MusicType">getMusicType</a></li>
  <li><a class="reference" href="#setPostMix%2Cproc%28pointer%2Cptr.uint8%2Ccint%29%2Cpointer"
    title="setPostMix*(mix_func: proc (udata: pointer; stream: ptr uint8; len: cint) {.
    cdecl.}; arg: pointer)">setPostMix</a></li>
  <li><a class="reference" href="#hookMusic%2Cproc%28pointer%2Cptr.uint8%2Ccint%29%2Cpointer"
    title="hookMusic*(mix_func: proc (udata: pointer; stream: ptr uint8; len: cint) {.cdecl.};
           arg: pointer)">hookMusic</a></li>
  <li><a class="reference" href="#hookMusicFinished%2Cproc%29"
    title="hookMusicFinished*(music_finished: proc () {.cdecl.})">hookMusicFinished</a></li>
  <li><a class="reference" href="#getMusicHookData"
    title="getMusicHookData*(): pointer">getMusicHookData</a></li>
  <li><a class="reference" href="#channelFinished%2Cproc%28cint%29"
    title="channelFinished*(channel_finished: proc (channel: cint) {.cdecl.})">channelFinished</a></li>
  <li><a class="reference" href="#registerEffect%2Ccint%2CEffectFunc_t%2CEffectDone_t%2Cpointer"
    title="registerEffect*(chan: cint; f: EffectFunc_t; d: EffectDone_t; arg: pointer): cint">registerEffect</a></li>
  <li><a class="reference" href="#unregisterEffect%2Ccint%2CEffectFunc_t"
    title="unregisterEffect*(channel: cint; f: EffectFunc_t): cint">unregisterEffect</a></li>
  <li><a class="reference" href="#unregisterAllEffects%2Ccint"
    title="unregisterAllEffects*(channel: cint): cint">unregisterAllEffects</a></li>
  <li><a class="reference" href="#setPanning%2Ccint%2Cuint8%2Cuint8"
    title="setPanning*(channel: cint; left: uint8; right: uint8): cint">setPanning</a></li>
  <li><a class="reference" href="#setPosition%2Ccint%2Cint16%2Cuint8"
    title="setPosition*(channel: cint; angle: int16; distance: uint8): cint">setPosition</a></li>
  <li><a class="reference" href="#setDistance%2Ccint%2Cuint8"
    title="setDistance*(channel: cint; distance: uint8): cint">setDistance</a></li>
  <li><a class="reference" href="#setReverseStereo%2Ccint%2Ccint"
    title="setReverseStereo*(channel: cint; flip: cint): cint">setReverseStereo</a></li>
  <li><a class="reference" href="#reserveChannels%2Ccint"
    title="reserveChannels*(num: cint): cint">reserveChannels</a></li>
  <li><a class="reference" href="#groupChannel%2Ccint%2Ccint"
    title="groupChannel*(which: cint; tag: cint): cint">groupChannel</a></li>
  <li><a class="reference" href="#groupChannels%2Ccint%2Ccint%2Ccint"
    title="groupChannels*(ch_from: cint; ch_to: cint; tag: cint): cint">groupChannels</a></li>
  <li><a class="reference" href="#groupAvailable%2Ccint"
    title="groupAvailable*(tag: cint): cint">groupAvailable</a></li>
  <li><a class="reference" href="#groupCount%2Ccint"
    title="groupCount*(tag: cint): cint">groupCount</a></li>
  <li><a class="reference" href="#groupOldest%2Ccint"
    title="groupOldest*(tag: cint): cint">groupOldest</a></li>
  <li><a class="reference" href="#groupNewer%2Ccint"
    title="groupNewer*(tag: cint): cint">groupNewer</a></li>
  <li><a class="reference" href="#playChannelTimed%2Ccint%2CChunk%2Ccint%2Ccint"
    title="playChannelTimed*(channel: cint; chunk: Chunk; loops: cint; ticks: cint): cint">playChannelTimed</a></li>
  <li><a class="reference" href="#playMusic%2CMusic%2Ccint"
    title="playMusic*(music: Music; loops: cint): cint">playMusic</a></li>
  <li><a class="reference" href="#fadeInMusic%2CMusic%2Ccint%2Ccint"
    title="fadeInMusic*(music: Music; loops: cint; ms: cint): cint">fadeInMusic</a></li>
  <li><a class="reference" href="#fadeInMusicPos%2CMusic%2Ccint%2Ccint%2Ccdouble"
    title="fadeInMusicPos*(music: Music; loops: cint; ms: cint; position: cdouble): cint">fadeInMusicPos</a></li>
  <li><a class="reference" href="#fadeInChannelTimed%2Ccint%2CChunk%2Ccint%2Ccint%2Ccint"
    title="fadeInChannelTimed*(channel: cint; chunk: Chunk; loops: cint; ms: cint;
                    ticks: cint): cint">fadeInChannelTimed</a></li>
  <li><a class="reference" href="#volume%2Ccint%2Ccint"
    title="volume*(channel: cint; volume: cint): cint">volume</a></li>
  <li><a class="reference" href="#volumeChunk%2CChunk%2Ccint"
    title="volumeChunk*(chunk: Chunk; volume: cint): cint">volumeChunk</a></li>
  <li><a class="reference" href="#volumeMusic%2Ccint"
    title="volumeMusic*(volume: cint): cint">volumeMusic</a></li>
  <li><a class="reference" href="#haltChannel%2Ccint"
    title="haltChannel*(channel: cint): cint">haltChannel</a></li>
  <li><a class="reference" href="#haltGroup%2Ccint"
    title="haltGroup*(tag: cint): cint">haltGroup</a></li>
  <li><a class="reference" href="#haltMusic"
    title="haltMusic*(): cint">haltMusic</a></li>
  <li><a class="reference" href="#expireChannel%2Ccint%2Ccint"
    title="expireChannel*(channel: cint; ticks: cint): cint">expireChannel</a></li>
  <li><a class="reference" href="#fadeOutChannel%2Ccint%2Ccint"
    title="fadeOutChannel*(which: cint; ms: cint): cint">fadeOutChannel</a></li>
  <li><a class="reference" href="#fadeOutGroup%2Ccint%2Ccint"
    title="fadeOutGroup*(tag: cint; ms: cint): cint">fadeOutGroup</a></li>
  <li><a class="reference" href="#fadeOutMusic%2Ccint"
    title="fadeOutMusic*(ms: cint): cint">fadeOutMusic</a></li>
  <li><a class="reference" href="#fadingMusic"
    title="fadingMusic*(): Fading">fadingMusic</a></li>
  <li><a class="reference" href="#fadingChannel%2Ccint"
    title="fadingChannel*(which: cint): Fading">fadingChannel</a></li>
  <li><a class="reference" href="#pause%2Ccint"
    title="pause*(channel: cint)">pause</a></li>
  <li><a class="reference" href="#resume%2Ccint"
    title="resume*(channel: cint)">resume</a></li>
  <li><a class="reference" href="#paused%2Ccint"
    title="paused*(channel: cint): cint">paused</a></li>
  <li><a class="reference" href="#pauseMusic"
    title="pauseMusic*()">pauseMusic</a></li>
  <li><a class="reference" href="#resumeMusic"
    title="resumeMusic*()">resumeMusic</a></li>
  <li><a class="reference" href="#rewindMusic"
    title="rewindMusic*()">rewindMusic</a></li>
  <li><a class="reference" href="#pausedMusic"
    title="pausedMusic*(): cint">pausedMusic</a></li>
  <li><a class="reference" href="#setMusicPosition%2Ccdouble"
    title="setMusicPosition*(position: cdouble): cint">setMusicPosition</a></li>
  <li><a class="reference" href="#playing%2Ccint"
    title="playing*(channel: cint): cint">playing</a></li>
  <li><a class="reference" href="#playingMusic"
    title="playingMusic*(): cint">playingMusic</a></li>
  <li><a class="reference" href="#setMusicCMD%2Ccstring"
    title="setMusicCMD*(command: cstring): cint">setMusicCMD</a></li>
  <li><a class="reference" href="#setSynchroValue%2Ccint"
    title="setSynchroValue*(value: cint): cint">setSynchroValue</a></li>
  <li><a class="reference" href="#getSynchroValue"
    title="getSynchroValue*(): cint">getSynchroValue</a></li>
  <li><a class="reference" href="#setSoundFonts%2Ccstring"
    title="setSoundFonts*(paths: cstring): cint">setSoundFonts</a></li>
  <li><a class="reference" href="#getSoundFonts"
    title="getSoundFonts*(): cstring">getSoundFonts</a></li>
  <li><a class="reference" href="#eachSoundFont%2Cproc%28cstring%2Cpointer%29%2Cpointer"
    title="eachSoundFont*(function: proc (a2: cstring; a3: pointer): cint {.cdecl.};
               data: pointer): cint">eachSoundFont</a></li>
  <li><a class="reference" href="#getChunk%2Ccint"
    title="getChunk*(channel: cint): Chunk">getChunk</a></li>
  <li><a class="reference" href="#closeAudio"
    title="closeAudio*()">closeAudio</a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#18" id="68">Templates</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#versionAtLeast.t%2Cuntyped%2Cuntyped%2Cuntyped"
    title="versionAtLeast*(x, y, z: untyped): untyped">versionAtLeast</a></li>
  <li><a class="reference" href="#loadWAV_RW.t%2Cptr.RWops%2Cbool"
    title="loadWAV_RW*(src: ptr RWops; freesrc: bool): Chunk">loadWAV_RW</a></li>
  <li><a class="reference" href="#loadWAV.t%2Cuntyped"
    title="loadWAV*(file: untyped): untyped">loadWAV</a></li>
  <li><a class="reference" href="#loadMUS_RW.t%2Cptr.RWops%2Cbool"
    title="loadMUS_RW*(src: ptr RWops; freesrc: bool): Music">loadMUS_RW</a></li>
  <li><a class="reference" href="#loadMUSType_RW.t%2Cptr.RWops%2CMusicType%2Cbool"
    title="loadMUSType_RW*(src: ptr RWops; kind: MusicType; freesrc: bool): Music">loadMUSType_RW</a></li>
  <li><a class="reference" href="#playChannel.t%2Cuntyped%2Cuntyped%2Cuntyped"
    title="playChannel*(channel, chunk, loops: untyped): untyped">playChannel</a></li>
  <li><a class="reference" href="#fadeInChannel.t%2Cuntyped%2Cuntyped%2Cuntyped%2Cuntyped"
    title="fadeInChannel*(channel, chunk, loops, ms: untyped): untyped">fadeInChannel</a></li>
  <li><a class="reference" href="#setError.t%2Cuntyped"
    title="setError*(fmt: untyped): cint">setError</a></li>
  <li><a class="reference" href="#getError.t"
    title="getError*(): cstring">getError</a></li>
  <li><a class="reference" href="#clearError.t"
    title="clearError*()">clearError</a></li>

  </ul>
</li>

</ul>

  </div>
  
  <div class="nine columns" id="content">
  <div id="tocRoot"></div>
  
  <p class="module-desc">
<h1><a class="toc-backref" id="sdl-mixerdotnim" href="#sdl-mixerdotnim">sdl_mixer.nim</a></h1><p>Multi-channel audio mixer library.</p>

<h1><a class="toc-backref" id="conflicts" href="#conflicts">Conflicts</a></h1><p>When using SDL_mixer procedures you need to avoid the following procedures from SDL:</p>
<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">sdl.openAudio()</span></tt></dt>
<dd>Use <tt class="docutils literal"><span class="pre">sdl_mixer.openAudio()</span></tt> instead.</dd>
<dt><tt class="docutils literal"><span class="pre">sdl.closeAudio()</span></tt></dt>
<dd>Use <tt class="docutils literal"><span class="pre">sdl_mixer.closeAudio()</span></tt> instead.</dd>
<dt><tt class="docutils literal"><span class="pre">sdl.pauseAudio()</span></tt></dt>
<dd><p>Use <tt class="docutils literal"><span class="pre">sdl_mixer.pause(-1)</span></tt> and <tt class="docutils literal"><span class="pre">sdl_mixer.pauseMusic()</span></tt> to pause.</p>
<p>Use <tt class="docutils literal"><span class="pre">sdl_mixer.resume(-1)</span></tt> and <tt class="docutils literal"><span class="pre">sdl_mixer.resumeMusic()</span></tt> to unpause.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">sdl.lockAudio()</span></tt></dt>
<dd><p>This is just not needed since SDL_mixer handles this for you.</p>
<p>Using it may cause problems as well.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">sdl.unlockAudio()</span></tt></dt>
<dd><p>This is just not needed since SDL_mixer handles this for you.</p>
<p>Using it may cause problems as well.</p>
</dd>
</dl>
<p>You may call the following procedures freely:</p>
<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">sdl.audioDriverName()</span></tt></dt>
<dd>This will still work as usual.</dd>
<dt><tt class="docutils literal"><span class="pre">sdl.getAudioStatus()</span></tt></dt>
<dd>This will still work, though it will likely return <tt class="docutils literal"><span class="pre">sdl.AUDIO_PLAYING</span></tt> even though SDL_mixer is just playing silence.</dd>
</dl>
<p>It is also a BAD idea to call SDL_mixer and SDL audio procedures from a callback. Callbacks include Effects procedures and other SDL_mixer audio hooks.</p>
</p>
  <div class="section" id="7">
<h1><a class="toc-backref" href="#7">Types</a></h1>
<dl class="item">
<a id="Chunk"></a>
<dt><pre><span class="Identifier">Chunk</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">ptr</span> <span class="Identifier">ChunkObj</span></pre></dt>
<dd>



</dd>
<a id="ChunkObj"></a>
<dt><pre><span class="Identifier">ChunkObj</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Identifier">allocated</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Comment">## a boolean indicating whether to free abuf when the chunk is freed.</span>
                   <span class="Comment">## </span>
                   <span class="Comment">## `0` if the memory was not allocated and thus not owned by this chunk.</span>
                   <span class="Comment">## </span>
                   <span class="Comment">## `1` if the memory was allocated and is thus owned by this chunk.</span>
  <span class="Identifier">abuf</span><span class="Operator">*</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">uint8</span>           <span class="Comment">## Pointer to the sample data,</span>
                             <span class="Comment">## which is in the output format and sample rate.</span>
  <span class="Identifier">alen</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint32</span>              <span class="Comment">## Length of abuf in bytes.</span>
  <span class="Identifier">volume</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>             <span class="Comment">## Per-sample volume,</span>
                             <span class="Comment">## `0` = silent, `128` = max volume. This takes effect when mixing.</span>
  </pre></dt>
<dd>

<p>
The internal format for an audio chunk</p>
<p>This stores the sample data, the length in bytes of that data, and the volume to use when mixing the sample.</p>


</dd>
<a id="Fading"></a>
<dt><pre><span class="Identifier">Fading</span><span class="Operator">*</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">sizeof</span><span class="Other">(</span><span class="Identifier">cint</span><span class="Other">)</span></span><span class="Other">.}</span></span> <span class="Other">=</span> <span class="Keyword">enum</span>
  <span class="Identifier">NO_FADING</span><span class="Other">,</span> <span class="Identifier">FADING_OUT</span><span class="Other">,</span> <span class="Identifier">FADING_IN</span></pre></dt>
<dd>

<p>
Return values from <tt class="docutils literal"><span class="pre">sdl_mixer.fadingMusic()</span></tt> and <tt class="docutils literal"><span class="pre">sdl_mixer.fadingChannel()</span></tt> are of these enumerated values.</p>
<p>If no fading is taking place on the queried channel or music, then <tt class="docutils literal"><span class="pre">MIX_NO_FADING</span></tt> is returned. Otherwise they are self explanatory.</p>


</dd>
<a id="MusicType"></a>
<dt><pre><span class="Identifier">MusicType</span><span class="Operator">*</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">sizeof</span><span class="Other">(</span><span class="Identifier">cint</span><span class="Other">)</span></span><span class="Other">.}</span></span> <span class="Other">=</span> <span class="Keyword">enum</span>
  <span class="Identifier">MUS_NONE</span><span class="Other">,</span> <span class="Identifier">MUS_CMD</span><span class="Other">,</span> <span class="Identifier">MUS_WAV</span><span class="Other">,</span> <span class="Identifier">MUS_MOD</span><span class="Other">,</span> <span class="Identifier">MUS_MID</span><span class="Other">,</span> <span class="Identifier">MUS_OGG</span><span class="Other">,</span> <span class="Identifier">MUS_MP3</span><span class="Other">,</span>
  <span class="Identifier">MUS_MP3_MAD_UNUSED</span><span class="Other">,</span> <span class="Identifier">MUS_FLAC</span><span class="Other">,</span> <span class="Identifier">MUS_MODPLUG_UNUSED</span><span class="Other">,</span> <span class="Identifier">MUS_OPUS</span></pre></dt>
<dd>

<p>
Return values from <tt class="docutils literal"><span class="pre">sdl_mixer.getMusicType()</span></tt> are of these enumerated values.</p>
<p>If no music is playing then <tt class="docutils literal"><span class="pre">MUS_NONE</span></tt> is returned.    ## If music is playing via an external command then <tt class="docutils literal"><span class="pre">MUS_CMD</span></tt> is returned. Otherwise they are self explanatory.</p>
<p>These are types of music files (not libraries used to load them).</p>


</dd>
<a id="Music"></a>
<dt><pre><span class="Identifier">Music</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Identifier">pointer</span></pre></dt>
<dd>


The internal format for a music chunk interpreted via mikmod

</dd>
<a id="EffectFunc_t"></a>
<dt><pre><span class="Identifier">EffectFunc_t</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">chan</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">stream</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">len</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">udata</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma">
    <span class="Identifier">cdecl</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>
This is the prototype for effect processing procedures.</p>
<p><tt class="docutils literal"><span class="pre">chan</span></tt> The channel number that this effect is effecting now. <tt class="docutils literal"><span class="pre">sdl_mixer.CHANNEL_POST</span></tt> is passed in for post processing effects over the final mix.</p>
<p><tt class="docutils literal"><span class="pre">stream</span></tt> The buffer containing the current sample to process.</p>
<p><tt class="docutils literal"><span class="pre">len</span></tt> The length of stream in bytes.</p>
<p><tt class="docutils literal"><span class="pre">udata</span></tt> User data pointer that was passed in to <tt class="docutils literal"><span class="pre">sdl_mixer.registerEffect()</span></tt> when registering this effect processor procedure.</p>
<p>These procedures are used to apply effects processing on a sample chunk. As a channel plays a sample, the registered effect procedures are called. Each effect would then read and perhaps alter the <tt class="docutils literal"><span class="pre">len</span></tt> bytes of <tt class="docutils literal"><span class="pre">stream</span></tt>. It may also be advantageous to keep the effect state in the <tt class="docutils literal"><span class="pre">udata</span></tt>, with would be setup when registering the effect procedure on a channel.</p>
<p>Your effect changes the contents of <tt class="docutils literal"><span class="pre">stream</span></tt> based on whatever parameters are significant, or just leaves it be, if you prefer. You can do whatever you like to the buffer, though, and it will continue in its changed state down the mixing pipeline, through any other effect procedures, then finally to be mixed with the rest of the channels and music for the final output stream.</p>
<p><tt class="docutils literal"><span class="pre">DO NOT EVER</span></tt> call <tt class="docutils literal"><span class="pre">lockAudio()</span></tt> from your callback procedure!</p>


</dd>
<a id="EffectDone_t"></a>
<dt><pre><span class="Identifier">EffectDone_t</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">chan</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">udata</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>
This is the prototype for effect processing procedures.</p>
<p><tt class="docutils literal"><span class="pre">chan</span></tt> The channel number that this effect is effecting now. <tt class="docutils literal"><span class="pre">sdl_mixer.CHANNEL_POST</span></tt> is passed in for post processing effects over the final mix.</p>
<p><tt class="docutils literal"><span class="pre">udata</span></tt> User data pointer that was passed in to <tt class="docutils literal"><span class="pre">sdl_mixer.registerEffect()</span></tt> when registering this effect processor procedure.</p>
<p>This is a callback that signifies that a channel has finished all its loops and has completed playback. This gets called if the buffer plays out normally, or if you call <tt class="docutils literal"><span class="pre">haltChannel()</span></tt>, implicitly stop a channel via <tt class="docutils literal"><span class="pre">allocateChannels()</span></tt>, or unregister a callback while it's still playing. At that time the effects processing procedure may want to reset some internal variables or free some memory. It should free memory at least, because the processor could be freed after this call.</p>
<p><tt class="docutils literal"><span class="pre">DO NOT EVER</span></tt> call <tt class="docutils literal"><span class="pre">lockAudio()</span></tt> from your callback procedure!</p>


</dd>

</dl></div>
<div class="section" id="10">
<h1><a class="toc-backref" href="#10">Consts</a></h1>
<dl class="item">
<a id="MAJOR_VERSION"></a>
<dt><pre><span class="Identifier">MAJOR_VERSION</span><span class="Operator">*</span> <span class="Other">=</span> <span class="DecNumber">2</span></pre></dt>
<dd>



</dd>
<a id="MINOR_VERSION"></a>
<dt><pre><span class="Identifier">MINOR_VERSION</span><span class="Operator">*</span> <span class="Other">=</span> <span class="DecNumber">0</span></pre></dt>
<dd>



</dd>
<a id="PATCHLEVEL"></a>
<dt><pre><span class="Identifier">PATCHLEVEL</span><span class="Operator">*</span> <span class="Other">=</span> <span class="DecNumber">4</span></pre></dt>
<dd>



</dd>
<a id="COMPILEDVERSION"></a>
<dt><pre><span class="Identifier">COMPILEDVERSION</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Identifier">versionNum</span><span class="Other">(</span><span class="Identifier">MAJOR_VERSION</span><span class="Other">,</span> <span class="Identifier">MINOR_VERSION</span><span class="Other">,</span> <span class="Identifier">PATCHLEVEL</span><span class="Other">)</span></pre></dt>
<dd>


This is the version number const for the current SDL_mixer version.

</dd>
<a id="INIT_FLAC"></a>
<dt><pre><span class="Identifier">INIT_FLAC</span><span class="Operator">*</span> <span class="Other">=</span> <span class="DecNumber">0x00000001</span></pre></dt>
<dd>

(.flac) requiring the FLAC library on system - 
also any command-line player, which is not mixed by SDL_mixer

</dd>
<a id="INIT_MOD"></a>
<dt><pre><span class="Identifier">INIT_MOD</span><span class="Operator">*</span> <span class="Other">=</span> <span class="DecNumber">0x00000002</span></pre></dt>
<dd>

(.mod .xm .s3m .669 .it .med and more) 
requiring libmikmod on system

</dd>
<a id="INIT_MODPLUG"></a>
<dt><pre><span class="Identifier">INIT_MODPLUG</span><span class="Operator">*</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">deprecated</span></span><span class="Other">.}</span></span> <span class="Other">=</span> <span class="DecNumber">0x00000004</span></pre></dt>
<dd>



</dd>
<a id="INIT_MP3"></a>
<dt><pre><span class="Identifier">INIT_MP3</span><span class="Operator">*</span> <span class="Other">=</span> <span class="DecNumber">0x00000008</span></pre></dt>
<dd>

(.mp3) requiring SMPEG or MAD library on system

</dd>
<a id="INIT_OGG"></a>
<dt><pre><span class="Identifier">INIT_OGG</span><span class="Operator">*</span> <span class="Other">=</span> <span class="DecNumber">0x00000010</span></pre></dt>
<dd>

(.ogg) requiring ogg/vorbis libraries on system

</dd>
<a id="INIT_MID"></a>
<dt><pre><span class="Identifier">INIT_MID</span><span class="Operator">*</span> <span class="Other">=</span> <span class="DecNumber">0x00000020</span></pre></dt>
<dd>



</dd>
<a id="INIT_OPUS"></a>
<dt><pre><span class="Identifier">INIT_OPUS</span><span class="Operator">*</span> <span class="Other">=</span> <span class="DecNumber">0x00000040</span></pre></dt>
<dd>



</dd>
<a id="CHANNELS"></a>
<dt><pre><span class="Identifier">CHANNELS</span><span class="Operator">*</span> <span class="Other">=</span> <span class="DecNumber">8</span></pre></dt>
<dd>

The default mixer has <tt class="docutils literal"><span class="pre">8</span></tt> simultaneous mixing channels

</dd>
<a id="DEFAULT_FREQUENCY"></a>
<dt><pre><span class="Identifier">DEFAULT_FREQUENCY</span><span class="Operator">*</span> <span class="Other">=</span> <span class="DecNumber">22050</span></pre></dt>
<dd>

Good default values for a PC soundcard

</dd>
<a id="DEFAULT_FORMAT"></a>
<dt><pre><span class="Identifier">DEFAULT_FORMAT</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Identifier">AUDIO_S16LSB</span></pre></dt>
<dd>



</dd>
<a id="DEFAULT_CHANNELS"></a>
<dt><pre><span class="Identifier">DEFAULT_CHANNELS</span><span class="Operator">*</span> <span class="Other">=</span> <span class="DecNumber">2</span></pre></dt>
<dd>



</dd>
<a id="MAX_VOLUME"></a>
<dt><pre><span class="Identifier">MAX_VOLUME</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Identifier">MIX_MAXVOLUME</span></pre></dt>
<dd>

Volume of a chunk

</dd>
<a id="CHANNEL_POST"></a>
<dt><pre><span class="Identifier">CHANNEL_POST</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Operator">-</span><span class="DecNumber">2</span></pre></dt>
<dd>



</dd>
<a id="EFFECTSMAXSPEED"></a>
<dt><pre><span class="Identifier">EFFECTSMAXSPEED</span><span class="Operator">*</span> <span class="Other">=</span> <span class="StringLit">&quot;MIX_EFFECTSMAXSPEED&quot;</span></pre></dt>
<dd>


These are the internally-defined mixing effects. They use the same API that effects defined in the application use, but are provided here as a convenience. Some effects can reduce their quality or use more memory in the name of speed; to enable this, make sure the environment variable <tt class="docutils literal"><span class="pre">EFFECTSMAXSPEED</span></tt> (see above) is defined before you call <tt class="docutils literal"><span class="pre">openAudio()</span></tt>.

</dd>

</dl></div>
<div class="section" id="12">
<h1><a class="toc-backref" href="#12">Procs</a></h1>
<dl class="item">
<a id="linkedVersion"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#linkedVersion"><span class="Identifier">linkedVersion</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">Version</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_Linked_Version&quot;</span><span class="Other">,</span>
                                     <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

This procedure gets the version of the dynamically linked SDL_mixer library. It should NOT be used to fill a version structure, instead you should use the <tt class="docutils literal"><span class="pre">version()</span></tt> template.

</dd>
<a id="init,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#init%2Ccint"><span class="Identifier">init</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">flags</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_Init&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Loads dynamic libraries and prepares them for use.</p>
<p><tt class="docutils literal"><span class="pre">flags</span></tt> bitwise OR'd set of sample/music formats to support by loading a library now from <tt class="docutils literal"><span class="pre">sdl_mixer.INIT_*</span></tt></p>
<p>Initialize by loading support as indicated by the flags, or at least return success if support is already loaded. You may call this multiple times, which will actually require you to call <tt class="docutils literal"><span class="pre">sdl_mixer.quit()</span></tt> just once to clean up. You may call this procedure with a <tt class="docutils literal"><span class="pre">0</span></tt> to retrieve whether support was built-in or not loaded yet.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> you can call <tt class="docutils literal"><span class="pre">sdl_mixer.init()</span></tt> with the right <tt class="docutils literal"><span class="pre">sdl_mixer.INIT_*</span></tt> flags OR'd together before you program gets busy, to prevent a later hiccup while it loads and unloads the library, and to check that you do have the support that you need before you try and use it.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> this procedure does not always set the error string, so do not depend on <tt class="docutils literal"><span class="pre">sdl_mixer.getError()</span></tt> being meaningful all the time.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the flags successfully initialized, or <tt class="docutils literal"><span class="pre">0</span></tt> on failure.</p>


</dd>
<a id="quit"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#quit"><span class="Identifier">quit</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_Quit&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Unloads libraries loaded with <tt class="docutils literal"><span class="pre">init()</span></tt>.</p>
<p>This procedure cleans up all dynamically loaded library handles, freeing memory. If support is required again it will be initialized again, either by <tt class="docutils literal"><span class="pre">sdl_mixer.init()</span></tt> or loading a sample or some music with dynamic support required. You may call this procedure when <tt class="docutils literal"><span class="pre">sdl_mixer.load*</span></tt> procedures are no longer needed for the <tt class="docutils literal"><span class="pre">sdl_mixer.INIT_*</span></tt> formats. You should call this procedure for each time <tt class="docutils literal"><span class="pre">sdl_mixer.init()</span></tt> was called, otherwise it may not free all the dynamic library resources until the program ends. This is done so that multiple unrelated modules of a program may call <tt class="docutils literal"><span class="pre">sdl_mixer.init()</span></tt> and <tt class="docutils literal"><span class="pre">sdl_mixer.quit()</span></tt> without affecting the others performance and needs.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> Since each call to <tt class="docutils literal"><span class="pre">sdl_mixer.init()</span></tt> may set different flags, there is no way, currently, to request how many times each one was initted. In other words, the only way to quit for sure is to do a loop like so:</p>
<pre class="listing"><span class="Comment"># force a quit</span>
<span class="Keyword">while</span> <span class="Identifier">sdl_mixer</span><span class="Operator">.</span><span class="Identifier">init</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">)</span> <span class="Operator">!=</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
  <span class="Identifier">sdl_mixer</span><span class="Operator">.</span><span class="Identifier">quit</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre>

</dd>
<a id="openAudio,cint,uint16,cint,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#openAudio%2Ccint%2Cuint16%2Ccint%2Ccint"><span class="Identifier">openAudio</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">frequency</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">format</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">;</span> <span class="Identifier">channels</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">chunksize</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_OpenAudio&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Open the mixer with a certain audio format.</p>
<p><tt class="docutils literal"><span class="pre">frequency</span></tt> Output sampling frequency in samples per second (Hz). you might use <tt class="docutils literal"><span class="pre">sdl_mixer.DEFAULT_FREQUENCY</span></tt> (22050) since that is a good value for most games. <tt class="docutils literal"><span class="pre">frequency</span></tt> would be <tt class="docutils literal"><span class="pre">44100</span></tt> for 44.1KHz, which is CD audio rate. Most games use <tt class="docutils literal"><span class="pre">22050</span></tt>, because <tt class="docutils literal"><span class="pre">44100</span></tt> requires too much CPU power on older computers.</p>
<p><tt class="docutils literal"><span class="pre">format</span></tt> Output sample format, based on SDL audio support. See <tt class="docutils literal"><span class="pre">audio.nim</span></tt> (<tt class="docutils literal"><span class="pre">AUDIO_*</span></tt>).</p>
<p><tt class="docutils literal"><span class="pre">channels</span></tt> Number of sound channels in output. Set to <tt class="docutils literal"><span class="pre">2</span></tt> for stereo, <tt class="docutils literal"><span class="pre">1</span></tt> for mono. This has nothing to do with mixing channels. <tt class="docutils literal"><span class="pre">sdl_mixer.Channels</span></tt> (8) mixing channels will be allocated by default.</p>
<p><tt class="docutils literal"><span class="pre">chunksize</span></tt> Bytes used per output sample. <tt class="docutils literal"><span class="pre">chunksize</span></tt> is the size of each mixed sample. The smaller this is the more your hooks will be called. If make this too small on a slow system, sound may skip. If made to large, sound effects will lag behind the action more. You want a happy medium for your target computer. You also may make this <tt class="docutils literal"><span class="pre">4096</span></tt>, or larger, if you are just playing music.</p>
<p>This must be called before using other procedures in this library.</p>
<p>SDL must be initialized with <tt class="docutils literal"><span class="pre">sdl.INIT_AUDIO</span></tt> before this call.</p>
<p>You may call this procedures multiple times, however you will have to call <tt class="docutils literal"><span class="pre">sdl_mixer.closeAudio()</span></tt> just as many times for the device to actually close. The format will not changed on subsequent calls until fully closed. So you will have to close all the way before trying to open with different format parameters.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <tt class="docutils literal"><span class="pre">0</span></tt> on success, <tt class="docutils literal"><span class="pre">-1</span></tt> on errors.</p>


</dd>
<a id="openAudioDevice,cint,uint16,cint,cint,cstring,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#openAudioDevice%2Ccint%2Cuint16%2Ccint%2Ccint%2Ccstring%2Ccint"><span class="Identifier">openAudioDevice</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">frequency</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">format</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">;</span> <span class="Identifier">channels</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span>
                      <span class="Identifier">chunksize</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">device</span><span class="Other">:</span> <span class="Identifier">cstring</span><span class="Other">;</span> <span class="Identifier">allowed_changes</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_OpenAudioDevice&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

Open the mixer with specific device and certain audio format.

</dd>
<a id="allocateChannels,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#allocateChannels%2Ccint"><span class="Identifier">allocateChannels</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">numchans</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_AllocateChannels&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Set the number of channels being mixed.</p>
<p><tt class="docutils literal"><span class="pre">numchans</span></tt> Number of channels to allocate for mixing. A negative number will not do anything, it will tell you how many channels are currently allocated.</p>
<p>This can be called multiple times, even with sounds playing. If <tt class="docutils literal"><span class="pre">numchans</span></tt> is less than the current number of channels, then the higher channels will be stopped, freed, and therefore not mixed any longer. It's probably not a good idea to change the size 1000 times a second though.</p>
<p>If any channels are deallocated, any callback set by <tt class="docutils literal"><span class="pre">sdl_mixer.channelFinished()</span></tt> will be called when each channel is halted to be freed.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> passing in zero WILL free all mixing channels, however music will still play.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the number of channels allocated. Never fails... but a high number of channels can segfault if you run out of memory. We're talking REALLY high!</p>


</dd>
<a id="querySpec,ptr.cint,ptr.uint16,ptr.cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#querySpec%2Cptr.cint%2Cptr.uint16%2Cptr.cint"><span class="Identifier">querySpec</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">frequency</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">format</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">uint16</span><span class="Other">;</span> <span class="Identifier">channels</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_QuerySpec&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Get the actual audio format in use by the opened audio device. This may or may not match the parameters you passed to <tt class="docutils literal"><span class="pre">sdl_mixer.openAudio()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">frequency</span></tt> A pointer to an <tt class="docutils literal"><span class="pre">int</span></tt> where the frequency actually used by the opened audio device will be stored.</p>
<p><tt class="docutils literal"><span class="pre">format</span></tt> A pointer to a <tt class="docutils literal"><span class="pre">uint16</span></tt> where the output format actually being used by the audio device will be stored.</p>
<p><tt class="docutils literal"><span class="pre">channels</span></tt> A pointer to an <tt class="docutils literal"><span class="pre">int</span></tt> where the number of audio channels will be stored. <tt class="docutils literal"><span class="pre">2</span></tt> will mean stereo, <tt class="docutils literal"><span class="pre">1</span></tt> will mean mono.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <tt class="docutils literal"><span class="pre">0</span></tt> on error. If the device was open the number of times it was opened will be returned. The values of the arguments variables are not set on an error.</p>


</dd>
<a id="loadWAV_RW,ptr.RWops,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#loadWAV_RW%2Cptr.RWops%2Ccint"><span class="Identifier">loadWAV_RW</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">src</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">RWops</span><span class="Other">;</span> <span class="Identifier">freesrc</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Chunk</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_LoadWAV_RW&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Load src for use as a sample.</p>
<p>This can load WAVE, AIFF, RIFF, OGG, and VOC formats. Using <tt class="docutils literal"><span class="pre">sdl.RWops</span></tt> is not covered here, but they enable you to load from almost any source.</p>
<p><tt class="docutils literal"><span class="pre">src</span></tt> The source <tt class="docutils literal"><span class="pre">sdl.RWops</span></tt> as a pointer. The sample is loaded from this.</p>
<p><tt class="docutils literal"><span class="pre">freesrc</span></tt> A non-zero value mean is will automatically close/free the <tt class="docutils literal"><span class="pre">src</span></tt> for you.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> You must call <tt class="docutils literal"><span class="pre">sdl.openAudio()</span></tt> before this. It must know the output characteristics so it can convert the sample for playback, it does this conversion at load time.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> a pointer to the sample as a <tt class="docutils literal"><span class="pre">sdl_mixer.chunk()</span></tt>. <tt class="docutils literal"><span class="pre">nil</span></tt> is returned on errors.</p>


</dd>
<a id="loadMUS,cstring"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#loadMUS%2Ccstring"><span class="Identifier">loadMUS</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">file</span><span class="Other">:</span> <span class="Identifier">cstring</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Music</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_LoadMUS&quot;</span><span class="Other">,</span>
                                      <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Load music file to use. This can load WAVE, MOD, MIDI, OGG, MP3, FLAC, and any file that you use a command to play with.</p>
<p><tt class="docutils literal"><span class="pre">file</span></tt> Name of music file to use.</p>
<p>If you are using an external command to play the music, you must call <tt class="docutils literal"><span class="pre">sdl_mixer.setMusicCMD()</span></tt> before this, otherwise the internal players will be used. Alternatively, if you have set an external command up and don't want to use it, you must call <tt class="docutils literal"><span class="pre">sdl_mixer.setMusicCMD(nil)</span></tt> to use the built-in players again.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> a pointer to a <tt class="docutils literal"><span class="pre">sdl_mixer.Music</span></tt>. <tt class="docutils literal"><span class="pre">nil</span></tt> is returned on errors.</p>


</dd>
<a id="loadMUS_RW,ptr.RWops,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#loadMUS_RW%2Cptr.RWops%2Ccint"><span class="Identifier">loadMUS_RW</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">src</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">RWops</span><span class="Other">;</span> <span class="Identifier">freesrc</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Music</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_LoadMUS_RW&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Load a music file from an RWop object (Ogg and MikMod specific currently).</p>
<p>Matt Campbell (matt@campbellhome.dhs.org) April 2000</p>


</dd>
<a id="loadMUSType_RW,ptr.RWops,MusicType,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#loadMUSType_RW%2Cptr.RWops%2CMusicType%2Ccint"><span class="Identifier">loadMUSType_RW</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">src</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">RWops</span><span class="Other">;</span> <span class="Identifier">kind</span><span class="Other">:</span> <span class="Identifier">MusicType</span><span class="Other">;</span> <span class="Identifier">freesrc</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Music</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_LoadMUSType_RW&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

Load a music file from an RWop object assuming a specific format.

</dd>
<a id="quickLoad_WAV,ptr.uint8"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#quickLoad_WAV%2Cptr.uint8"><span class="Identifier">quickLoad_WAV</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">mem</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">uint8</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Chunk</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_QuickLoad_WAV&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Load mem as a WAVE/RIFF file into a new sample.</p>
<p>The WAVE in mem must be already in the output format. It would be better to use <tt class="docutils literal"><span class="pre">sdl_mixer.loadWAV_RW()</span></tt> if you aren't sure.</p>
<p><tt class="docutils literal"><span class="pre">mem</span></tt> Memory buffer containing a WAVE file in output format.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> This procedure does very little checking. If the format mismatches the output format, or if the buffer is not a WAVE, it will not return an error. This is probably a dangerous procedure to use.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> a pointer to the sample as a <tt class="docutils literal"><span class="pre">sdl_mixer.Chunk</span></tt>. <tt class="docutils literal"><span class="pre">nil</span></tt> is returned on errors.</p>


</dd>
<a id="quickLoad_RAW,ptr.uint8,uint32"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#quickLoad_RAW%2Cptr.uint8%2Cuint32"><span class="Identifier">quickLoad_RAW</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">mem</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">uint8</span><span class="Other">;</span> <span class="Identifier">len</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Chunk</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_QuickLoad_RAW&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Load mem as a raw sample.</p>
<p>The data in mem must be already in the output format. If you aren't sure what you are doing, this is not a good procedure for you!</p>
<p><tt class="docutils literal"><span class="pre">mem</span></tt> Memory buffer containing a WAVE file in output format.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> This procedure does very little checking. If the format mismatches the output format it will not return an error. This is probably a dangerous procedure to use.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> a pointer to the sample as a <tt class="docutils literal"><span class="pre">sdl_mixer.Chunk</span></tt>. <tt class="docutils literal"><span class="pre">nil</span></tt> is returned on errors, such as when out of memory.</p>


</dd>
<a id="freeChunk,Chunk"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#freeChunk%2CChunk"><span class="Identifier">freeChunk</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">chunk</span><span class="Other">:</span> <span class="Identifier">Chunk</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_FreeChunk&quot;</span><span class="Other">,</span>
                                <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Free the memory used in <tt class="docutils literal"><span class="pre">chunk</span></tt>, and free <tt class="docutils literal"><span class="pre">chunk</span></tt> itself as well. Do not use <tt class="docutils literal"><span class="pre">chunk</span></tt> after this without loading a new sample to it.</p>
<p><tt class="docutils literal"><span class="pre">chunk</span></tt> Pointer to the <tt class="docutils literal"><span class="pre">sdl_mixer.Chunk</span></tt> to free.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> It's a bad idea to free a chunk that is still being played...</p>


</dd>
<a id="freeMusic,Music"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#freeMusic%2CMusic"><span class="Identifier">freeMusic</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">music</span><span class="Other">:</span> <span class="Identifier">Music</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_FreeMusic&quot;</span><span class="Other">,</span>
                                <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Free the loaded <tt class="docutils literal"><span class="pre">music</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">music</span></tt> Pointer to <tt class="docutils literal"><span class="pre">sdl_mixer.Music</span></tt> to free.</p>
<p>If <tt class="docutils literal"><span class="pre">music</span></tt> is playing it will be halted. If <tt class="docutils literal"><span class="pre">music</span></tt> is fading out, then this procedure will wait (blocking) until the fade out is complete.</p>


</dd>
<a id="getNumChunkDecoders"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#getNumChunkDecoders"><span class="Identifier">getNumChunkDecoders</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_GetNumChunkDecoders&quot;</span><span class="Other">,</span>
                                    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Get a list of chunk/music decoders that this build of SDL_mixer provides.</p>
<p>This list can change between builds AND runs of the program, if external libraries that add functionality become available. You must successfully call <tt class="docutils literal"><span class="pre">openAudio()</span></tt> before calling these procedures. This API is only available in SDL_mixer 1.2.9 and later.</p>
<p>Usage:</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">cint</span>
<span class="Keyword">const</span> <span class="Identifier">total</span><span class="Punctuation">:</span> <span class="Identifier">cint</span> <span class="Operator">=</span> <span class="Identifier">getNumChunkDecoders</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">total</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Supported chunk decoder: [$1]&quot;</span> <span class="Operator">%</span> <span class="Punctuation">[</span><span class="Identifier">getChunkDecoder</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span><span class="Punctuation">]</span></pre><p>Appearing in this list doesn't promise your specific audio file will decode...but it's handy to know if you have, say, a functioning Timidity install.</p>
<p>These return values are static, read-only data; do not modify or free it. The pointers remain valid until you call <tt class="docutils literal"><span class="pre">closeAudio()</span></tt>.</p>


</dd>
<a id="getChunkDecoder,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#getChunkDecoder%2Ccint"><span class="Identifier">getChunkDecoder</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cstring</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_GetChunkDecoder&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Get the name of the indexed sample chunk decoder. You need to get the number of sample chunk decoders available using the <tt class="docutils literal"><span class="pre">sdl_mixer.getNumChunkDecoders()</span></tt> procedure.</p>
<p><tt class="docutils literal"><span class="pre">index</span></tt> The index number of sample chunk decoder to get. In the range from <tt class="docutils literal"><span class="pre">0</span></tt> to <tt class="docutils literal"><span class="pre">sdl_mixer.getNumChunkDecoders()</span></tt>-1, inclusive.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the name of the indexed sample chunk decoder. This string is owned by the SDL_mixer library, do not modify or free it. It is valid until you call <tt class="docutils literal"><span class="pre">sdl_mixer.closeAudio()</span></tt> the final time.</p>


</dd>
<a id="hasChunkDecoder,cstring"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#hasChunkDecoder%2Ccstring"><span class="Identifier">hasChunkDecoder</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">name</span><span class="Other">:</span> <span class="Identifier">cstring</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_HasChunkDecoder&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>



</dd>
<a id="getNumMusicDecoders"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#getNumMusicDecoders"><span class="Identifier">getNumMusicDecoders</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_GetNumMusicDecoders&quot;</span><span class="Other">,</span>
                                    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Get the number of music decoders available from the <tt class="docutils literal"><span class="pre">sdl_mixer.getMusicDecoder()</span></tt> procedure.</p>
<p>This number can be different for each run of a program, due to the change in availability of shared libraries that support each format.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the number of music decoders available.</p>


</dd>
<a id="getMusicDecoder,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#getMusicDecoder%2Ccint"><span class="Identifier">getMusicDecoder</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cstring</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_GetMusicDecoder&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Get the name of the <tt class="docutils literal"><span class="pre">index</span></tt>'ed music decoder. You need to get the number of music decoders available using the <tt class="docutils literal"><span class="pre">sdl_mixer.getNumMusicDecoders()</span></tt> procedure.</p>
<p><tt class="docutils literal"><span class="pre">index</span></tt> The index number of music decoder to get. In the range from <tt class="docutils literal"><span class="pre">0</span></tt> to <tt class="docutils literal"><span class="pre">sdl_mixer.getNumMusicDecoders()</span></tt>-1, inclusive.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the name of the <tt class="docutils literal"><span class="pre">index</span></tt>'ed music decoder. This string is owned by the SDL_mixer library, do not modify or free it. It is valid until you call <tt class="docutils literal"><span class="pre">sdl_mixer.closeAudio()</span></tt> the final time.</p>


</dd>
<a id="getMusicType,Music"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#getMusicType%2CMusic"><span class="Identifier">getMusicType</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">music</span><span class="Other">:</span> <span class="Identifier">Music</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">MusicType</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_GetMusicType&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Find out the music format of a mixer music, or the currently playing music, if <tt class="docutils literal"><span class="pre">music</span></tt> is <tt class="docutils literal"><span class="pre">nil</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">music</span></tt> The music to get the type of. <tt class="docutils literal"><span class="pre">nil</span></tt> will get the currently playing music type.</p>
<p>Tells you the file format encoding of the music. This may be handy when used with <tt class="docutils literal"><span class="pre">sdl_mixer.setMusicPosition()</span></tt>, and other music procedures that vary based on the type of music being played. If you want to know the type of music currently being played, pass in <tt class="docutils literal"><span class="pre">nil</span></tt> to <tt class="docutils literal"><span class="pre">music</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the type of <tt class="docutils literal"><span class="pre">music</span></tt> or if <tt class="docutils literal"><span class="pre">music</span></tt> is <tt class="docutils literal"><span class="pre">nil</span></tt> then the currently playing music type, otherwise <tt class="docutils literal"><span class="pre">MUS_NONE</span></tt> if no music is playing.</p>


</dd>
<a id="setPostMix,proc(pointer,ptr.uint8,cint),pointer"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#setPostMix%2Cproc%28pointer%2Cptr.uint8%2Ccint%29%2Cpointer"><span class="Identifier">setPostMix</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">mix_func</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">udata</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">stream</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">uint8</span><span class="Other">;</span> <span class="Identifier">len</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma">
    <span class="Identifier">cdecl</span></span><span class="Other">.}</span></span><span class="Other">;</span> <span class="Identifier">arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_SetPostMix&quot;</span><span class="Other">,</span>
                             <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Set a procedure that is called after all mixing is performed.</p>
<p><tt class="docutils literal"><span class="pre">mix_func</span></tt> The procedure pointer for the postmix processor. <tt class="docutils literal"><span class="pre">nil</span></tt> unregisters the current postmixer.</p>
<p><tt class="docutils literal"><span class="pre">arg</span></tt> A pointer to data to pass into the <tt class="docutils literal"><span class="pre">mix_func</span></tt>'s <tt class="docutils literal"><span class="pre">udata</span></tt> parameter. It is a good place to keep the state data for the processor, especially if the processor is made to handle multiple channels at the same time. This may be <tt class="docutils literal"><span class="pre">nil</span></tt>, depending on the processor.</p>
<p>This can be used to provide real-time visual display of the audio stream or add a custom mixer filter for the stream data.</p>
<p>You may just be reading the data and displaying it, or you may be altering the stream to add an echo. Most processors also have state data that they allocate as they are in use, this would be stored in the <tt class="docutils literal"><span class="pre">arg</span></tt> pointer data space. This processor is never really finished, until the audio device is closed, or you pass <tt class="docutils literal"><span class="pre">nil</span></tt> as the <tt class="docutils literal"><span class="pre">mix_func</span></tt>.</p>
<p>There can only be one postmix procedure used at a time through this method. Use <tt class="docutils literal"><span class="pre">sdl_mixer.registerEffect(CHANNEL_POST, mix_func, nil, arg)</span></tt> to use multiple postmix processors.</p>
<p>This postmix processor is run AFTER all the registered postmixers set up by <tt class="docutils literal"><span class="pre">sdl_mixer.registerEffect()</span></tt>.</p>


</dd>
<a id="hookMusic,proc(pointer,ptr.uint8,cint),pointer"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#hookMusic%2Cproc%28pointer%2Cptr.uint8%2Ccint%29%2Cpointer"><span class="Identifier">hookMusic</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">mix_func</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">udata</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">stream</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">uint8</span><span class="Other">;</span> <span class="Identifier">len</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma">
    <span class="Identifier">cdecl</span></span><span class="Other">.}</span></span><span class="Other">;</span> <span class="Identifier">arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_HookMusic&quot;</span><span class="Other">,</span>
                             <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Add your own music player or additional mixer procedure.</p>
<p><tt class="docutils literal"><span class="pre">mix_func</span></tt> Procedure pointer to a music player mixer procedure. <tt class="docutils literal"><span class="pre">nil</span></tt> will stop the use of the music player, returning the mixer to using the internal music players like usual.</p>
<p><tt class="docutils literal"><span class="pre">arg</span></tt> This is passed to the <tt class="docutils literal"><span class="pre">mix_func</span></tt>'s udata parameter when it is called.</p>
<p>This sets up a custom music player procedure. The procedure will be called with <tt class="docutils literal"><span class="pre">arg</span></tt> passed into the <tt class="docutils literal"><span class="pre">udata</span></tt> parameter when the <tt class="docutils literal"><span class="pre">mix_func</span></tt> is called. The <tt class="docutils literal"><span class="pre">stream</span></tt> parameter passes in the audio stream buffer to be filled with <tt class="docutils literal"><span class="pre">len</span></tt> bytes of music.</p>
<p>The music player will then be called automatically when the mixer needs it. Music playing will start as soon as this is called.</p>
<p>All the music playing and stopping procedures have no effect on music after this. Pause and resume will work.</p>
<p>Using a custom music player and the internal music player is not possible, the custom music player takes priority. To stop the custom music player call <tt class="docutils literal"><span class="pre">sdl_mixer.hookMusic(nil, nil)</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> NEVER call SDL_Mixer procedures, nor <tt class="docutils literal"><span class="pre">sdl.lockAudio()</span></tt>, from a callback procedure.</p>


</dd>
<a id="hookMusicFinished,proc)"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#hookMusicFinished%2Cproc%29"><span class="Identifier">hookMusicFinished</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">music_finished</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span></span><span class="Other">.}</span></span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_HookMusicFinished&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Add your own callback for when the music has finished playing or when it is stopped from a call to <tt class="docutils literal"><span class="pre">mix.haltMusic()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">music_finished</span></tt> Procedure pointer to a <tt class="docutils literal"><span class="pre">proc() {.cdecl.}</span></tt>. <tt class="docutils literal"><span class="pre">nil</span></tt> will remove the hook.</p>
<p>This sets up a procedure to be called when music playback is halted. Any time music stops, the music_finished procedure will be called. Call with <tt class="docutils literal"><span class="pre">nil</span></tt> to remove the callback.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> NEVER call SDL_Mixer procedures, nor <tt class="docutils literal"><span class="pre">sdl.lockAudio()</span></tt>, from a callback procedure.</p>


</dd>
<a id="getMusicHookData"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#getMusicHookData"><span class="Identifier">getMusicHookData</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">pointer</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_GetMusicHookData&quot;</span><span class="Other">,</span>
                                    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Get the <tt class="docutils literal"><span class="pre">arg</span></tt> passed into <tt class="docutils literal"><span class="pre">sdl_mixer.hookMusic()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the <tt class="docutils literal"><span class="pre">arg</span></tt> pointer.</p>


</dd>
<a id="channelFinished,proc(cint)"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#channelFinished%2Cproc%28cint%29"><span class="Identifier">channelFinished</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">channel_finished</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">channel</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span></span><span class="Other">.}</span></span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_ChannelFinished&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Add your own callback when a channel has finished playing.</p>
<p><tt class="docutils literal"><span class="pre">channel_finished</span></tt> Procedure to call when any channel finishes playback. <tt class="docutils literal"><span class="pre">nil</span></tt> to disable callback. The callback may be called from the mixer's audio callback or it could be called as a result of <tt class="docutils literal"><span class="pre">sdl_mixer.haltChannel()</span></tt>, etc.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> NEVER call SDL_Mixer procedures, nor <tt class="docutils literal"><span class="pre">sdl.lockAudio()</span></tt> from a callback procedure.</p>


</dd>
<a id="registerEffect,cint,EffectFunc_t,EffectDone_t,pointer"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#registerEffect%2Ccint%2CEffectFunc_t%2CEffectDone_t%2Cpointer"><span class="Identifier">registerEffect</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">chan</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">f</span><span class="Other">:</span> <span class="Identifier">EffectFunc_t</span><span class="Other">;</span> <span class="Identifier">d</span><span class="Other">:</span> <span class="Identifier">EffectDone_t</span><span class="Other">;</span> <span class="Identifier">arg</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_RegisterEffect&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Register a special effect procedure.</p>
<p><tt class="docutils literal"><span class="pre">chan</span></tt> Channel number to register <tt class="docutils literal"><span class="pre">f</span></tt> and <tt class="docutils literal"><span class="pre">d</span></tt> on. Use <tt class="docutils literal"><span class="pre">sdl_mixer.CHANNEL_POST</span></tt> to process the postmix stream.</p>
<p><tt class="docutils literal"><span class="pre">f</span></tt> The procedure pointer for the effects processor.</p>
<p><tt class="docutils literal"><span class="pre">d</span></tt> The procedure pointer for any cleanup routine to be called when the channel is done playing a sample. This may be <tt class="docutils literal"><span class="pre">nil</span></tt> for any processors that don't need to clean up any memory or other dynamic data.</p>
<p><tt class="docutils literal"><span class="pre">arg</span></tt> A pointer to data to pass into the <tt class="docutils literal"><span class="pre">f</span></tt>'s and <tt class="docutils literal"><span class="pre">d</span></tt>'s <tt class="docutils literal"><span class="pre">udata</span></tt> parameter. It is a good place to keep the state data for the processor, especially if the processor is made to handle multiple channels at the same time. This may be <tt class="docutils literal"><span class="pre">nil</span></tt>, depending on the processor.</p>
<p>Hook a processor procedure <tt class="docutils literal"><span class="pre">f</span></tt> into a channel for post processing effects. You may just be reading the data and displaying it, or you may be altering the stream to add an echo. Most processors also have state data that they allocate as they are in use, this would be stored in the <tt class="docutils literal"><span class="pre">arg</span></tt> pointer data space. When a processor is finished being used, any procedure passed into <tt class="docutils literal"><span class="pre">d</span></tt> will be called, which is when your processor should clean up the data in the <tt class="docutils literal"><span class="pre">arg</span></tt> data space.</p>
<p>The effects are put into a linked list, and always appended to the end, meaning they always work on previously registered effects output. Effects may be added multiple times in a row. Effects are cumulative this way.</p>
<p>At mixing time, the channel data is copied into a buffer and passed through each registered effect procedure. After it passes through all the procedures, it is mixed into the final output stream. The copy to buffer is performed once, then each effect procedure performs on the output of the previous effect. Understand that this extra copy to a buffer is not performed if there are no effects registered for a given chunk, which saves CPU cycles, and any given effect will be extra cycles, too, so it is crucial that your code run fast. Also note that the data that your procedure is given is in the format of the sound device, and not the format you gave to <tt class="docutils literal"><span class="pre">openAudio()</span></tt>, although they may in reality be the same. This is an unfortunate but necessary speed concern. Use <tt class="docutils literal"><span class="pre">querySpec()</span></tt> to determine if you can handle the data before you register your effect, and take appropriate actions.</p>
<p>You may also specify a callback (<tt class="docutils literal"><span class="pre">EffectDone_t</span></tt>) that is called when the channel finishes playing. This gives you a more fine-grained control than <tt class="docutils literal"><span class="pre">channelFinished()</span></tt>, in case you need to free effect-specific resources, etc. If you don't need this, you can specify <tt class="docutils literal"><span class="pre">nil</span></tt>.</p>
<p>You may set the callbacks before or after calling <tt class="docutils literal"><span class="pre">playChannel()</span></tt>.</p>
<p>Things like <tt class="docutils literal"><span class="pre">setPanning()</span></tt> are just internal special effect procedures, so if you are using that, you've already incurred the overhead of a copy to a separate buffer, and that these effects will be in the queue with any procedures you've registered. The list of registered effects for a channel is reset when a chunk finishes playing, so you need to explicitly set them with each call to <tt class="docutils literal"><span class="pre">playChannel()</span></tt>.</p>
<p>You may also register a special effect procedure that is to be run after final mixing occurs. The rules for these callbacks are identical to those in <tt class="docutils literal"><span class="pre">registerEffect()</span></tt>, but they are run after all the channels and the music have been mixed into a single stream, whereas channel-specific effects run on a given channel before any other mixing occurs. These global effect callbacks are call &quot;posteffects&quot;. Posteffects only have their <tt class="docutils literal"><span class="pre">EffectDone_t</span></tt> proceudre called when they are unregistered (since the main output stream is never &quot;done&quot; in the same sense as a channel). You must unregister them manually when you've had enough. Your callback will be told that the channel being mixed is (<tt class="docutils literal"><span class="pre">CHANNEL_POST</span></tt>) if the processing is considered a posteffect.</p>
<p>After all these effects have finished processing, the callback registered through <tt class="docutils literal"><span class="pre">setPostMix()</span></tt> runs, and then the stream goes to the audio device.</p>
<p><tt class="docutils literal"><span class="pre">DO NOT EVER</span></tt> call <tt class="docutils literal"><span class="pre">lockAudio()</span></tt> from your callback procedure!</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <tt class="docutils literal"><span class="pre">0</span></tt> if error (no such channel), nonzero if added.</p>
<p>Error messages can be retrieved from <tt class="docutils literal"><span class="pre">getError()</span></tt>.</p>


</dd>
<a id="unregisterEffect,cint,EffectFunc_t"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#unregisterEffect%2Ccint%2CEffectFunc_t"><span class="Identifier">unregisterEffect</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">channel</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">f</span><span class="Other">:</span> <span class="Identifier">EffectFunc_t</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_UnregisterEffect&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Remove the oldest (first found) registered effect procedure <tt class="docutils literal"><span class="pre">f</span></tt> from the effect list for <tt class="docutils literal"><span class="pre">channel</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">channel</span></tt> Channel number to remove <tt class="docutils literal"><span class="pre">f</span></tt> from as a post processor. Use <tt class="docutils literal"><span class="pre">sdl_mixer.CHANNEL_POST</span></tt> for the postmix stream.</p>
<p><tt class="docutils literal"><span class="pre">f</span></tt> The procedure to remove from <tt class="docutils literal"><span class="pre">channel</span></tt>.</p>
<p>This only removes the first found occurance of that procedure, so it may need to be called multiple times if you added the same procedure multiple times, just stop removing when <tt class="docutils literal"><span class="pre">sdl_mixer.unregisterEffect()</span></tt> returns an error, to remove all occurances of <tt class="docutils literal"><span class="pre">f</span></tt> from a channel.</p>
<p>If the <tt class="docutils literal"><span class="pre">channel</span></tt> is active the registered effect will have its <tt class="docutils literal"><span class="pre">sdl_mixer.EffectDone_t</span></tt> procedure called, if it was specified in <tt class="docutils literal"><span class="pre">sdl_mixer.registerEffect()</span></tt>.</p>
<p>You may not need to call this explicitly, unless you need to stop an effect from processing in the middle of a chunk's playback.</p>
<p>Posteffects are never implicitly unregistered as they are for channels, but they may be explicitly unregistered through this procedure by specifying <tt class="docutils literal"><span class="pre">CHANNEL_POST</span></tt> for a channel.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <tt class="docutils literal"><span class="pre">0</span></tt> if error (no such channel or effect), nonzero if removed.</p>
<p>Error messages can be retrieved from <tt class="docutils literal"><span class="pre">getError()</span></tt>.</p>


</dd>
<a id="unregisterAllEffects,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#unregisterAllEffects%2Ccint"><span class="Identifier">unregisterAllEffects</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">channel</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_UnregisterAllEffects&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>This removes all effects registered to <tt class="docutils literal"><span class="pre">channel</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">channel</span></tt> Channel to remove all effects from. Use <tt class="docutils literal"><span class="pre">sdl_mixer.CHANNEL_POST</span></tt> for the postmix stream.</p>
<p>If the <tt class="docutils literal"><span class="pre">channel</span></tt> is active, all the registered effects will have their <tt class="docutils literal"><span class="pre">sdl_mixer.EffectDone_t</span></tt> procedures called, if they were specified in <tt class="docutils literal"><span class="pre">sdl_mixer.registerEffect()</span></tt>.</p>
<p>You may not need to call this explicitly, unless you need to stop all effects from processing in the middle of a chunk's playback. Note that this will also shut off some internal effect processing, since <tt class="docutils literal"><span class="pre">setPanning()</span></tt> and others may use this API under the hood. This is called internally when a channel completes playback.</p>
<p>Posteffects are never implicitly unregistered as they are for channels, but they may be explicitly unregistered through this procedure by specifying <tt class="docutils literal"><span class="pre">CHANNEL_POST</span></tt> for a channel.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <tt class="docutils literal"><span class="pre">0</span></tt> if error (no such channel), nonzero if all effects removed.</p>
<p>Error messages can be retrieved from <tt class="docutils literal"><span class="pre">getError()</span></tt>.</p>


</dd>
<a id="setPanning,cint,uint8,uint8"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#setPanning%2Ccint%2Cuint8%2Cuint8"><span class="Identifier">setPanning</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">channel</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">left</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span> <span class="Identifier">right</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_SetPanning&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Set the panning of a <tt class="docutils literal"><span class="pre">channel</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">channel</span></tt> Channel number to register this effect on. Use <tt class="docutils literal"><span class="pre">sdl_mixer.CHANNEL_POST</span></tt> to process the postmix stream.</p>
<p><tt class="docutils literal"><span class="pre">left</span></tt> Volume for the left channel, range is <tt class="docutils literal"><span class="pre">0</span></tt> (silence) to <tt class="docutils literal"><span class="pre">255</span></tt> (loud).</p>
<p><tt class="docutils literal"><span class="pre">right</span></tt> Volume for the right channel, range is <tt class="docutils literal"><span class="pre">0</span></tt> (silence) to <tt class="docutils literal"><span class="pre">255</span></tt> (loud).</p>
<p>This effect will only work on stereo audio. Meaning you called <tt class="docutils literal"><span class="pre">sdl_mixer.openAudio()</span></tt> with <tt class="docutils literal"><span class="pre">2</span></tt> channels (<tt class="docutils literal"><span class="pre">sdl_mixer.DEFAULT_CHANNELS</span></tt>). The easiest way to do true panning is to call <tt class="docutils literal"><span class="pre">sdl_mixer.setPanning(channel, left, 254 - left)</span></tt> so that the total volume is correct, if you consider the maximum volume to be <tt class="docutils literal"><span class="pre">127</span></tt> per channel for center, or <tt class="docutils literal"><span class="pre">254</span></tt> max for left, this works, but about halves the effective volume.</p>
<p>This procedure registers the effect for you, so don't try to <tt class="docutils literal"><span class="pre">sdl_mixer.registerEffect()</span></tt> it yourself.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> Setting both left and right to <tt class="docutils literal"><span class="pre">255</span></tt> will unregister the effect from channel. You cannot unregister it any other way, unless you use <tt class="docutils literal"><span class="pre">sdl_mixer.unregisterAllEffects()</span></tt> on the channel.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> Using this procedure on a mono audio device will not register the effect, nor will it return an error status.</p>
<p>Setting <tt class="docutils literal"><span class="pre">channel</span></tt> to <tt class="docutils literal"><span class="pre">CHANNEL_POST</span></tt> registers this as a posteffect, and the panning will be done to the final mixed stream before passing it on to the audio device.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <tt class="docutils literal"><span class="pre">0</span></tt> if error (no such channel or <tt class="docutils literal"><span class="pre">registerEffect()</span></tt> fails), nonzero if panning effect enabled. Note that an audio device in mono mode is a no-op, but this call will return successful in that case.</p>
<p>Error messages can be retrieved from <tt class="docutils literal"><span class="pre">getError()</span></tt>.</p>


</dd>
<a id="setPosition,cint,int16,uint8"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#setPosition%2Ccint%2Cint16%2Cuint8"><span class="Identifier">setPosition</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">channel</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">angle</span><span class="Other">:</span> <span class="Identifier">int16</span><span class="Other">;</span> <span class="Identifier">distance</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_SetPosition&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Set the position of a <tt class="docutils literal"><span class="pre">channel</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">channel</span></tt> Channel number to register this effect on. Use <tt class="docutils literal"><span class="pre">sdl_mixer.CHANNEL_POST</span></tt> to process the postmix stream.</p>
<p><tt class="docutils literal"><span class="pre">angle</span></tt> Direction in relation to forward from <tt class="docutils literal"><span class="pre">0</span></tt> to <tt class="docutils literal"><span class="pre">360</span></tt> degrees. Larger angles will be reduced to this range using <tt class="docutils literal"><span class="pre">angle mod 360</span></tt>.</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> = directly in front.</li>
<li><tt class="docutils literal"><span class="pre">90</span></tt> = directly to the right.</li>
<li><tt class="docutils literal"><span class="pre">180</span></tt> = directly behind.</li>
<li><tt class="docutils literal"><span class="pre">270</span></tt> = directly to the left.</li>
</ul>
<p>So you can see it goes clockwise starting at directly in front. This ends up being similar in effect to <tt class="docutils literal"><span class="pre">sdl_mixer.setPanning()</span></tt> For efficiency, the precision of this effect may be limited (angles <tt class="docutils literal"><span class="pre">1</span></tt> through <tt class="docutils literal"><span class="pre">7</span></tt> might all produce the same effect, <tt class="docutils literal"><span class="pre">8</span></tt> through <tt class="docutils literal"><span class="pre">15</span></tt> are equal, etc).</p>
<p><tt class="docutils literal"><span class="pre">distance</span></tt> The distance from the listener, from <tt class="docutils literal"><span class="pre">0</span></tt> (near/loud) to <tt class="docutils literal"><span class="pre">255 (far/quiet). This is the same as the ``sdl_mixer.setDistance()`` effect. For efficiency, the precision of this effect may be limited (distance `0</span></tt> through <tt class="docutils literal"><span class="pre">5</span></tt> might all produce the same effect, <tt class="docutils literal"><span class="pre">6</span></tt> through <tt class="docutils literal"><span class="pre">10</span></tt> are equal, etc).</p>
<p>This effect emulates a simple 3D audio effect. It's not all that realistic, but it can help improve some level of realism. By giving it the <tt class="docutils literal"><span class="pre">angle</span></tt> and <tt class="docutils literal"><span class="pre">distance</span></tt> from the camera's point of view, the effect pans and attenuates volumes. If you are looking for better positional audio, using OpenAL is suggested.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> Using angle and distance of <tt class="docutils literal"><span class="pre">0</span></tt>, will cause the effect to unregister itself from <tt class="docutils literal"><span class="pre">channel</span></tt>. You cannot unregister it any other way, unless you use <tt class="docutils literal"><span class="pre">sdl_mixer.unregisterAllEffects()</span></tt> on the <tt class="docutils literal"><span class="pre">channel</span></tt>.</p>
<p>If the audio device is configured for mono output, then you won't get any effectiveness from the <tt class="docutils literal"><span class="pre">angle</span></tt>; however, distance attenuation on the channel will still occur. While this effect will function with stereo voices, it makes more sense to use voices with only one channel of sound, so when they are mixed through this effect, the positioning will sound correct. You can convert them to mono through SDL before giving them to the mixer in the first place if you like.</p>
<p>Setting <tt class="docutils literal"><span class="pre">channel</span></tt> to <tt class="docutils literal"><span class="pre">sdl_mixer.CHANNEL_POST</span></tt> registers this as a posteffect, and the positioning will be done to the final mixed stream before passing it on to the audio device.</p>
<p>This is a convenience wrapper over <tt class="docutils literal"><span class="pre">setDistance()</span></tt> and <tt class="docutils literal"><span class="pre">setPanning()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <tt class="docutils literal"><span class="pre">0</span></tt> if error (no such channel or <tt class="docutils literal"><span class="pre">registerEffect()</span></tt> fails), nonzero if position effect is enabled.</p>
<p>Error messages can be retrieved from <tt class="docutils literal"><span class="pre">getError()</span></tt>.</p>


</dd>
<a id="setDistance,cint,uint8"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#setDistance%2Ccint%2Cuint8"><span class="Identifier">setDistance</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">channel</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">distance</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_SetDistance&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Set the <tt class="docutils literal"><span class="pre">distance</span></tt> of a <tt class="docutils literal"><span class="pre">channel</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">channel</span></tt> Channel number to register this effect on. Use <tt class="docutils literal"><span class="pre">sdl_mixer.CHANNEL_POST</span></tt> to process the postmix stream.</p>
<p><tt class="docutils literal"><span class="pre">distance</span></tt> Specify the distance from the listener, from <tt class="docutils literal"><span class="pre">0</span></tt> (close/loud) to <tt class="docutils literal"><span class="pre">255</span></tt> (far/quiet). A distance of <tt class="docutils literal"><span class="pre">255</span></tt> does not guarantee silence; in such a case, you might want to try changing the chunk's volume, or just cull the sample from the mixing process with <tt class="docutils literal"><span class="pre">sdl_mixer.haltChannel()</span></tt>.</p>
<p>This effect simulates a simple attenuation of volume due to distance. The volume never quite reaches silence, even at max distance.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> Using a distance of <tt class="docutils literal"><span class="pre">0</span></tt> will cause the effect to unregister itself from <tt class="docutils literal"><span class="pre">channel</span></tt>. You cannot unregister it any other way, unless you use <tt class="docutils literal"><span class="pre">sdl_mixer.unregisterAllEffects()</span></tt> on the <tt class="docutils literal"><span class="pre">channel</span></tt>.</p>
<p>For efficiency, the precision of this effect may be limited (distances <tt class="docutils literal"><span class="pre">1</span></tt> through <tt class="docutils literal"><span class="pre">7</span></tt> might all produce the same effect, <tt class="docutils literal"><span class="pre">8</span></tt> through <tt class="docutils literal"><span class="pre">15</span></tt> are equal, etc).</p>
<p>If you need more precise positional audio, consider using OpenAL for spatialized effects instead of SDL_mixer. This is only meant to be a basic effect for simple &quot;3D&quot; games.</p>
<p>Setting <tt class="docutils literal"><span class="pre">channel</span></tt> to <tt class="docutils literal"><span class="pre">sdl_mixer.CHANNEL_POST</span></tt> registers this as a posteffect, and the distance attenuation will be done to the final mixed stream before passing it on to the audio device.</p>
<p>This uses the <tt class="docutils literal"><span class="pre">registerEffect()</span></tt> API internally.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <tt class="docutils literal"><span class="pre">0</span></tt> if error (no such channel or <tt class="docutils literal"><span class="pre">sdl_mixer.registerEffect()</span></tt> fails), nonzero if position effect is enabled.</p>
<p>Error messages can be retrieved from <tt class="docutils literal"><span class="pre">getError()</span></tt>.</p>


</dd>
<a id="setReverseStereo,cint,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#setReverseStereo%2Ccint%2Ccint"><span class="Identifier">setReverseStereo</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">channel</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">flip</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_SetReverseStereo&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Simple reverse stereo, swaps left and right channel sound.</p>
<p><tt class="docutils literal"><span class="pre">channel</span></tt> Channel number to register this effect on. Use <tt class="docutils literal"><span class="pre">sdl_mixer.CHANNEL_POST</span></tt> to process the postmix stream.</p>
<p><tt class="docutils literal"><span class="pre">flip</span></tt> Must be non-zero to work, means nothing to the effect processor itself. Set to <tt class="docutils literal"><span class="pre">0</span></tt> to unregister the effect from channel.</p>
<p>Causes a <tt class="docutils literal"><span class="pre">channel</span></tt> to reverse its stereo. This is handy if the user has his speakers hooked up backwards, or you would like to have a minor bit of psychedelia in your sound code.  :)</p>
<p>Calling this procedure with <tt class="docutils literal"><span class="pre">flip</span></tt> set to non-zero reverses the chunks's usual channels. If <tt class="docutils literal"><span class="pre">flip</span></tt> is zero, the effect is unregistered.</p>
<p>This uses the <tt class="docutils literal"><span class="pre">registerEffect()</span></tt> API internally, and thus is probably more CPU intensive than having the user just plug in his speakers correctly. <tt class="docutils literal"><span class="pre">setReverseStereo()</span></tt> returns without registering the effect procedure if the audio device is not configured for stereo output.</p>
<p>If you specify <tt class="docutils literal"><span class="pre">CHANNEL_POST</span></tt> for <tt class="docutils literal"><span class="pre">channel</span></tt>, then this the effect is used on the final mixed stream before sending it on to the audio device (a posteffect).</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> Using a flip of <tt class="docutils literal"><span class="pre">0</span></tt>, will cause the effect to unregister itself from <tt class="docutils literal"><span class="pre">channel</span></tt>. You cannot unregister it any other way, unless you use <tt class="docutils literal"><span class="pre">sdl_mixer.unregisterAllEffects()</span></tt> on the <tt class="docutils literal"><span class="pre">channel</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <tt class="docutils literal"><span class="pre">0</span></tt> if error (no such channel or <tt class="docutils literal"><span class="pre">registerEffect()</span></tt> fails), nonzero if reversing effect is enabled. Note that an audio device in mono mode is a no-op, but this call will return successful in that case.</p>
<p>Error messages can be retrieved from <tt class="docutils literal"><span class="pre">getError()</span></tt>.</p>


</dd>
<a id="reserveChannels,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#reserveChannels%2Ccint"><span class="Identifier">reserveChannels</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">num</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_ReserveChannels&quot;</span><span class="Other">,</span>
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Reserve <tt class="docutils literal"><span class="pre">num</span></tt> channels from being used when playing samples when passing in <tt class="docutils literal"><span class="pre">-1</span></tt> as a channel number to playback procedures. The channels are reserved starting from channel <tt class="docutils literal"><span class="pre">0</span></tt> to <tt class="docutils literal"><span class="pre">num</span></tt>-1. Passing in <tt class="docutils literal"><span class="pre">0</span></tt> will unreserve all channels. Normally SDL_mixer starts without any channels reserved.</p>
<p><tt class="docutils literal"><span class="pre">num</span></tt> Number of channels to reserve from default mixing. <tt class="docutils literal"><span class="pre">0</span></tt> removes all reservations.</p>
<p>The following procedures are affected by this setting:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">sdl_mixer.playChannel()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">sdl_mixer.playChannelTimed()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">sdl_mixer.fadeInChannel()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">sdl_mixer.fadeInChannelTimed()</span></tt></li>
</ul>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the number of channels reserved. Never fails, but may return less channels than you ask for, depending on the number of channels previously allocated.</p>


</dd>
<a id="groupChannel,cint,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#groupChannel%2Ccint%2Ccint"><span class="Identifier">groupChannel</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">which</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">tag</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_GroupChannel&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Add <tt class="docutils literal"><span class="pre">which</span></tt> channel to group tag, or reset it's group to the default group tag (<tt class="docutils literal"><span class="pre">-1</span></tt>).</p>
<p><tt class="docutils literal"><span class="pre">which</span></tt> Channel number of channels to assign tag to.</p>
<p><tt class="docutils literal"><span class="pre">tag</span></tt> A group number. Any positive numbers (including zero). <tt class="docutils literal"><span class="pre">-1</span></tt> is the default group. Use <tt class="docutils literal"><span class="pre">-1</span></tt> to remove a group tag essentially.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <tt class="docutils literal"><span class="pre">1</span></tt> on success. <tt class="docutils literal"><span class="pre">0</span></tt> is returned when the channel specified is invalid.</p>


</dd>
<a id="groupChannels,cint,cint,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#groupChannels%2Ccint%2Ccint%2Ccint"><span class="Identifier">groupChannels</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ch_from</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">ch_to</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">tag</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_GroupChannels&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Add channels starting at <tt class="docutils literal"><span class="pre">ch_from</span></tt> up through <tt class="docutils literal"><span class="pre">ch_to</span></tt> to group tag, or reset it's group to the default group tag (<tt class="docutils literal"><span class="pre">-1</span></tt>).</p>
<p><tt class="docutils literal"><span class="pre">ch_from</span></tt> First Channel number of channels to assign tag to. Must be less or equal to <tt class="docutils literal"><span class="pre">ch_to</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">ch_to</span></tt> Last Channel number of channels to assign tag to. Must be greater or equal to <tt class="docutils literal"><span class="pre">ch_from</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">tag</span></tt> A group number. Any positive numbers (including zero). <tt class="docutils literal"><span class="pre">-1</span></tt> is the default group. Use <tt class="docutils literal"><span class="pre">-1</span></tt> to remove a group tag essentially.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the number of tagged channels on success. If that number is less than <tt class="docutils literal"><span class="pre">ch_to</span></tt> - <tt class="docutils literal"><span class="pre">ch_from</span></tt> + 1 then some channels were no tagged because they didn't exist.</p>


</dd>
<a id="groupAvailable,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#groupAvailable%2Ccint"><span class="Identifier">groupAvailable</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">tag</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_GroupAvailable&quot;</span><span class="Other">,</span>
                                        <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Finds the first available (not playing) channel in a group <tt class="docutils literal"><span class="pre">tag</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">tag</span></tt>  group number. Any positive numbers (including zero). <tt class="docutils literal"><span class="pre">-1</span></tt> will search ALL channels.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the channel found on success. <tt class="docutils literal"><span class="pre">-1</span></tt> is returned when no channels in the group are available.</p>


</dd>
<a id="groupCount,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#groupCount%2Ccint"><span class="Identifier">groupCount</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">tag</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_GroupCount&quot;</span><span class="Other">,</span>
                                    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Count the number of channels in group <tt class="docutils literal"><span class="pre">tag</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">tag</span></tt> A group number. Any positive numbers (including zero). <tt class="docutils literal"><span class="pre">-1</span></tt> will count ALL channels.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the number of channels in a group. This procedure never fails. This is also a subtle way to get the total number of channels when <tt class="docutils literal"><span class="pre">tag</span></tt> is <tt class="docutils literal"><span class="pre">-1</span></tt>.</p>


</dd>
<a id="groupOldest,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#groupOldest%2Ccint"><span class="Identifier">groupOldest</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">tag</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_GroupOldest&quot;</span><span class="Other">,</span>
                                     <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Find the &quot;oldest&quot; sample playing in a group <tt class="docutils literal"><span class="pre">tag</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">tag</span></tt> A group number. Any positive numbers (including zero). <tt class="docutils literal"><span class="pre">-1</span></tt> will search ALL channels.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the channel found on success. <tt class="docutils literal"><span class="pre">-1</span></tt> is returned when no channels in the group are playing or the group is empty.</p>


</dd>
<a id="groupNewer,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#groupNewer%2Ccint"><span class="Identifier">groupNewer</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">tag</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_GroupNewer&quot;</span><span class="Other">,</span>
                                    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Find the &quot;most recent&quot; (i.e. last) sample playing in a group <tt class="docutils literal"><span class="pre">tag</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">tag</span></tt> A group number. Any positive numbers (including zero). <tt class="docutils literal"><span class="pre">-1</span></tt> will search ALL channels.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the channel found on success. <tt class="docutils literal"><span class="pre">-1</span></tt> is returned when no channels in the group are playing or the group is empty.</p>


</dd>
<a id="playChannelTimed,cint,Chunk,cint,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#playChannelTimed%2Ccint%2CChunk%2Ccint%2Ccint"><span class="Identifier">playChannelTimed</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">channel</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">chunk</span><span class="Other">:</span> <span class="Identifier">Chunk</span><span class="Other">;</span> <span class="Identifier">loops</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">ticks</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_PlayChannelTimed&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>The same as <tt class="docutils literal"><span class="pre">sdl_mixer.playChannel()</span></tt>, but the sound is played at most <tt class="docutils literal"><span class="pre">ticks</span></tt> milliseconds.</p>
<p><tt class="docutils literal"><span class="pre">channel</span></tt> Channel to play on, or <tt class="docutils literal"><span class="pre">-1</span></tt> for the first free unreserved channel.</p>
<p><tt class="docutils literal"><span class="pre">chunk</span></tt> Sample to play.</p>
<p><tt class="docutils literal"><span class="pre">loops</span></tt> Number of loops, <tt class="docutils literal"><span class="pre">-1</span></tt> is infinite loops. Passing <tt class="docutils literal"><span class="pre">1</span></tt> here plays the sample twice (1 loop).</p>
<p><tt class="docutils literal"><span class="pre">ticks</span></tt> Millisecond limit to play sample, at most. If not enough loops or the sample chunk is not long enough, then the sample may stop before this timeout occurs. <tt class="docutils literal"><span class="pre">-1</span></tt> means play forever.</p>
<p>If the sample is long enough and has enough loops then the sample will stop after <tt class="docutils literal"><span class="pre">ticks</span></tt> milliseconds. Otherwise this procedure is the same as <tt class="docutils literal"><span class="pre">sdl_mixer.playChannel()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the channel the sample is played on. On any errors, <tt class="docutils literal"><span class="pre">-1</span></tt> is returned.</p>


</dd>
<a id="playMusic,Music,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#playMusic%2CMusic%2Ccint"><span class="Identifier">playMusic</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">music</span><span class="Other">:</span> <span class="Identifier">Music</span><span class="Other">;</span> <span class="Identifier">loops</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_PlayMusic&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Play the loaded <tt class="docutils literal"><span class="pre">music</span></tt> <tt class="docutils literal"><span class="pre">loops</span></tt> times through from start to finish.</p>
<p><tt class="docutils literal"><span class="pre">music</span></tt> Pointer to <tt class="docutils literal"><span class="pre">sdl_mixer.Music</span></tt> to play.</p>
<p><tt class="docutils literal"><span class="pre">loops</span></tt> Number of times to play through the <tt class="docutils literal"><span class="pre">music</span></tt>. <tt class="docutils literal"><span class="pre">0</span></tt> plays the music zero times. <tt class="docutils literal"><span class="pre">-1</span></tt> plays the music forever (or as close as it can get to that).</p>
<p>The previous music will be halted, or if fading out it waits (blocking) for that to finish.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <tt class="docutils literal"><span class="pre">0</span></tt> on success, or <tt class="docutils literal"><span class="pre">-1</span></tt> on errors.</p>


</dd>
<a id="fadeInMusic,Music,cint,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#fadeInMusic%2CMusic%2Ccint%2Ccint"><span class="Identifier">fadeInMusic</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">music</span><span class="Other">:</span> <span class="Identifier">Music</span><span class="Other">;</span> <span class="Identifier">loops</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">ms</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_FadeInMusic&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Fade in over <tt class="docutils literal"><span class="pre">ms</span></tt> milliseconds of time, the loaded <tt class="docutils literal"><span class="pre">music</span></tt>, playing it <tt class="docutils literal"><span class="pre">loops</span></tt> times through from start to finish.</p>
<p><tt class="docutils literal"><span class="pre">music</span></tt> Pointer to <tt class="docutils literal"><span class="pre">sdl_mixer.Music</span></tt> to play.</p>
<p><tt class="docutils literal"><span class="pre">loops</span></tt> Number of times to play through the <tt class="docutils literal"><span class="pre">music</span></tt>. <tt class="docutils literal"><span class="pre">0</span></tt> plays the music zero times. <tt class="docutils literal"><span class="pre">-1</span></tt> plays the music forever (or as close as it can get to that).</p>
<p><tt class="docutils literal"><span class="pre">ms</span></tt> Milliseconds for the fade-in effect to complete.</p>
<p>The fade in effect only applies to the first loop.</p>
<p>Any previous music will be halted, or if it is fading out it will wait (blocking) for the fade to complete. This procedure is the same as <tt class="docutils literal"><span class="pre">sdl_mixer.fadeInMusicPos(music, loops, ms, 0)</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <tt class="docutils literal"><span class="pre">0</span></tt> on success, or <tt class="docutils literal"><span class="pre">-1</span></tt> on errors.</p>


</dd>
<a id="fadeInMusicPos,Music,cint,cint,cdouble"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#fadeInMusicPos%2CMusic%2Ccint%2Ccint%2Ccdouble"><span class="Identifier">fadeInMusicPos</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">music</span><span class="Other">:</span> <span class="Identifier">Music</span><span class="Other">;</span> <span class="Identifier">loops</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">ms</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">position</span><span class="Other">:</span> <span class="Identifier">cdouble</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma">
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_FadeInMusicPos&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Fade in over <tt class="docutils literal"><span class="pre">ms</span></tt> milliseconds of time, the loaded <tt class="docutils literal"><span class="pre">music</span></tt>, playing it <tt class="docutils literal"><span class="pre">loops</span></tt> times through from start to finish.</p>
<p><tt class="docutils literal"><span class="pre">music</span></tt> Pointer to <tt class="docutils literal"><span class="pre">sdl_mixer.Music</span></tt> to play.</p>
<p><tt class="docutils literal"><span class="pre">loops</span></tt> Number of times to play through the music. <tt class="docutils literal"><span class="pre">0</span></tt> plays the music zero times. <tt class="docutils literal"><span class="pre">-1</span></tt> plays the music forever (or as close as it can get to that).</p>
<p><tt class="docutils literal"><span class="pre">ms</span></tt> Milliseconds for the fade-in effect to complete.</p>
<p><tt class="docutils literal"><span class="pre">position</span></tt> Posistion to play from, see <tt class="docutils literal"><span class="pre">sdl_mixer.setMusicPosition()</span></tt> for meaning.</p>
<p>The fade in effect only applies to the first loop.</p>
<p>The first time the music is played, it posistion will be set to <tt class="docutils literal"><span class="pre">posistion</span></tt>, which means different things for different types of music files, see <tt class="docutils literal"><span class="pre">sdl_mixer.setMusicPosition()</span></tt> for more info on that.</p>
<p>Any previous music will be halted, or if it is fading out it will wait (blocking) for the fade to complete.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <tt class="docutils literal"><span class="pre">0</span></tt> on success, or <tt class="docutils literal"><span class="pre">-1</span></tt> on errors.</p>


</dd>
<a id="fadeInChannelTimed,cint,Chunk,cint,cint,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#fadeInChannelTimed%2Ccint%2CChunk%2Ccint%2Ccint%2Ccint"><span class="Identifier">fadeInChannelTimed</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">channel</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">chunk</span><span class="Other">:</span> <span class="Identifier">Chunk</span><span class="Other">;</span> <span class="Identifier">loops</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">ms</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span>
                         <span class="Identifier">ticks</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_FadeInChannelTimed&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>The same as <tt class="docutils literal"><span class="pre">sdl_mixer.fadeInChannel()</span></tt>, but the sound is played at most <tt class="docutils literal"><span class="pre">ticks</span></tt> milliseconds.</p>
<p><tt class="docutils literal"><span class="pre">channel</span></tt> Channel to play on, or <tt class="docutils literal"><span class="pre">-1</span></tt> for the first free unreserved channel.</p>
<p><tt class="docutils literal"><span class="pre">chunk</span></tt> Sample to play.</p>
<p><tt class="docutils literal"><span class="pre">loops</span></tt> Number of loops, <tt class="docutils literal"><span class="pre">-1</span></tt> is infinite loops. Passing <tt class="docutils literal"><span class="pre">1</span></tt> here plays the sample twice (1 loop).</p>
<p><tt class="docutils literal"><span class="pre">ms</span></tt> Milliseconds of time that the fade-in effect should take to go from silence to full volume.</p>
<p><tt class="docutils literal"><span class="pre">ticks</span></tt> Millisecond limit to play sample, at most. If not enough loops or the sample chunk is not long enough, then the sample may stop before this timeout occurs. <tt class="docutils literal"><span class="pre">-1</span></tt> means play forever.</p>
<p>If the sample is long enough and has enough loops then the sample will stop after <tt class="docutils literal"><span class="pre">ticks</span></tt> milliseconds. Otherwise this procedures is the same as <tt class="docutils literal"><span class="pre">sdl_mixer.fadeInChannel()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the channel the sample is played on. On any errors, <tt class="docutils literal"><span class="pre">-1</span></tt> is returned.</p>


</dd>
<a id="volume,cint,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#volume%2Ccint%2Ccint"><span class="Identifier">volume</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">channel</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">volume</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_Volume&quot;</span><span class="Other">,</span>
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Set the volume for any allocated channel.</p>
<p><tt class="docutils literal"><span class="pre">channel</span></tt> Channel to set mix volume for. <tt class="docutils literal"><span class="pre">-1</span></tt> will set the volume for all allocated channels.</p>
<p><tt class="docutils literal"><span class="pre">volume</span></tt> The volume to use from <tt class="docutils literal"><span class="pre">0</span></tt> to <tt class="docutils literal"><span class="pre">sdl_mixer.MAX_VOLUME</span></tt> (128). If greater than <tt class="docutils literal"><span class="pre">sdl_mixer.MAX_VOLUME</span></tt>, then it will be set to <tt class="docutils literal"><span class="pre">sdl_mixer.MAX_VOLUME</span></tt>. If less than <tt class="docutils literal"><span class="pre">0</span></tt> then the volume will not be set.</p>
<p>If <tt class="docutils literal"><span class="pre">channel</span></tt> is <tt class="docutils literal"><span class="pre">-1</span></tt> then all channels at are set at once. The <tt class="docutils literal"><span class="pre">volume</span></tt> is applied during the final mix, along with the sample volume. So setting this volume to <tt class="docutils literal"><span class="pre">64</span></tt> will halve the output of all samples played on the specified channel. All channels default to a volume of <tt class="docutils literal"><span class="pre">128</span></tt>, which is the max. Newly allocated channels will have the max volume set, so setting all channels volumes does not affect subsequent channel allocations.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> current volume of the channel. If channel is <tt class="docutils literal"><span class="pre">-1</span></tt>, the average volume is returned.</p>


</dd>
<a id="volumeChunk,Chunk,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#volumeChunk%2CChunk%2Ccint"><span class="Identifier">volumeChunk</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">chunk</span><span class="Other">:</span> <span class="Identifier">Chunk</span><span class="Other">;</span> <span class="Identifier">volume</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_VolumeChunk&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Set <tt class="docutils literal"><span class="pre">chunk.volume</span></tt> to <tt class="docutils literal"><span class="pre">volume</span></tt>.</p>
<p>The volume setting will take effect when the chunk is used on a channel, being mixed into the output.</p>
<p><tt class="docutils literal"><span class="pre">chunk</span></tt> Pointer to the <tt class="docutils literal"><span class="pre">sdl_mixer.chunk</span></tt> to set the volume in.</p>
<p><tt class="docutils literal"><span class="pre">volume</span></tt> The volume to use from <tt class="docutils literal"><span class="pre">0</span></tt> to <tt class="docutils literal"><span class="pre">sdl_mixer.MAX_VOLUME</span></tt> (128). If greater than <tt class="docutils literal"><span class="pre">sdl_mixer.MAX_VOLUME</span></tt>, then it will be set to <tt class="docutils literal"><span class="pre">sdl_mixer.MAX_VOLUME</span></tt>. If less than <tt class="docutils literal"><span class="pre">0</span></tt> then <tt class="docutils literal"><span class="pre">chunk.volume</span></tt> will not be set.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> previous <tt class="docutils literal"><span class="pre">chunk.volume</span></tt> setting. If you passed a negative value for <tt class="docutils literal"><span class="pre">volume</span></tt> then this volume is still the current volume for the <tt class="docutils literal"><span class="pre">chunk</span></tt>.</p>


</dd>
<a id="volumeMusic,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#volumeMusic%2Ccint"><span class="Identifier">volumeMusic</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">volume</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_VolumeMusic&quot;</span><span class="Other">,</span>
                                        <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Set the volume to <tt class="docutils literal"><span class="pre">volume</span></tt>, if it is <tt class="docutils literal"><span class="pre">0</span></tt> or greater, and return the previous volume setting.</p>
<p><tt class="docutils literal"><span class="pre">volume</span></tt> Music volume, from <tt class="docutils literal"><span class="pre">0</span></tt> to <tt class="docutils literal"><span class="pre">sdl_mixer.MAX_VOLUME</span></tt> (128). Values greater than <tt class="docutils literal"><span class="pre">sdl_mixer.MAX_VOLUME</span></tt> will use <tt class="docutils literal"><span class="pre">sdl_mixer.MAX_VOLUME</span></tt>. <tt class="docutils literal"><span class="pre">-1</span></tt> does not set the volume, but does return the current volume setting.</p>
<p>Setting the volume during a fade will not work, the faders use this procedure to perform their effect!</p>
<p>Setting volume while using an external music player set by <tt class="docutils literal"><span class="pre">sdl_mixer.setMusicCMD()</span></tt> will have no effect, and <tt class="docutils literal"><span class="pre">sdl_mixer.getError()</span></tt> will show the reason why not.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the previous volume setting.</p>


</dd>
<a id="haltChannel,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#haltChannel%2Ccint"><span class="Identifier">haltChannel</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">channel</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_HaltChannel&quot;</span><span class="Other">,</span>
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Halt <tt class="docutils literal"><span class="pre">channel</span></tt> playback, or all channels if <tt class="docutils literal"><span class="pre">-1</span></tt> is passed in.</p>
<p><tt class="docutils literal"><span class="pre">channel</span></tt> Channel to stop playing, or <tt class="docutils literal"><span class="pre">-1</span></tt> for all channels.</p>
<p>Any callback set by <tt class="docutils literal"><span class="pre">sdl_mixer.channelFinished()</span></tt> will be called.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> always returns zero. (kinda silly)</p>


</dd>
<a id="haltGroup,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#haltGroup%2Ccint"><span class="Identifier">haltGroup</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">tag</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_HaltGroup&quot;</span><span class="Other">,</span>
                                   <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Halt playback on all channels in group tag.</p>
<p><tt class="docutils literal"><span class="pre">tag</span></tt> Group to fade out. <tt class="docutils literal"><span class="pre">Note:</span></tt> <tt class="docutils literal"><span class="pre">-1</span></tt> will NOT halt all channels. Use <tt class="docutils literal"><span class="pre">sdl_mixer.haltChannel(-1)</span></tt> for that instead.</p>
<p>Any callback set by <tt class="docutils literal"><span class="pre">sdl_mixer.channelFinished()</span></tt> will be called once for each channel that stops.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> always returns zero. (more silly than <tt class="docutils literal"><span class="pre">sdl_mixer.haltChannel()</span></tt>)</p>


</dd>
<a id="haltMusic"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#haltMusic"><span class="Identifier">haltMusic</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_HaltMusic&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Halt playback of music.</p>
<p>This interrupts music fader effects.</p>
<p>Any callback set by <tt class="docutils literal"><span class="pre">sdl_mixer.hookMusicFinished()</span></tt> will be called when the music stops.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> always returns zero. (even more silly than <tt class="docutils literal"><span class="pre">sdl_mixer.haltGroup()</span></tt>)</p>


</dd>
<a id="expireChannel,cint,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#expireChannel%2Ccint%2Ccint"><span class="Identifier">expireChannel</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">channel</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">ticks</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_ExpireChannel&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Halt <tt class="docutils literal"><span class="pre">channel</span></tt> playback, or all channels if <tt class="docutils literal"><span class="pre">-1</span></tt> is passed in, after <tt class="docutils literal"><span class="pre">ticks</span></tt> milliseconds.</p>
<p><tt class="docutils literal"><span class="pre">channel</span></tt> Channel to stop playing, or <tt class="docutils literal"><span class="pre">-1</span></tt> for all channels.</p>
<p><tt class="docutils literal"><span class="pre">ticks</span></tt> Millisecons until channel(s) halt playback.</p>
<p>Any callback set by <tt class="docutils literal"><span class="pre">sdl_mixer.channelFinished()</span></tt> will be called when the channel expires.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> number of channels set to expire. Whether or not they are active.</p>


</dd>
<a id="fadeOutChannel,cint,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#fadeOutChannel%2Ccint%2Ccint"><span class="Identifier">fadeOutChannel</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">which</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">ms</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_FadeOutChannel&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Gradually fade out <tt class="docutils literal"><span class="pre">which</span></tt> channel over <tt class="docutils literal"><span class="pre">ms</span></tt> milliseconds starting from now.</p>
<p><tt class="docutils literal"><span class="pre">channel</span></tt> Channel to fade out, or <tt class="docutils literal"><span class="pre">-1</span></tt> to fade all channels out.</p>
<p><tt class="docutils literal"><span class="pre">ms</span></tt> Milliseconds of time that the fade-out effect should take to go to silence, starting now.</p>
<p>The channel will be halted after the fade out is completed. Only channels that are playing are set to fade out, including paused channels.</p>
<p>Any callback set by <tt class="docutils literal"><span class="pre">sdl_mixer.channelFinished()</span></tt> will be called when the channel finishes fading out.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the number of channels set to fade out.</p>


</dd>
<a id="fadeOutGroup,cint,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#fadeOutGroup%2Ccint%2Ccint"><span class="Identifier">fadeOutGroup</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">tag</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">ms</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_FadeOutGroup&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Gradually fade out channels in group <tt class="docutils literal"><span class="pre">tag</span></tt> over <tt class="docutils literal"><span class="pre">ms</span></tt> milliseconds starting from now.</p>
<p><tt class="docutils literal"><span class="pre">tag</span></tt> Group to fade out. <tt class="docutils literal"><span class="pre">Note:</span></tt> <tt class="docutils literal"><span class="pre">-1</span></tt> will NOT fade all channels out. Use <tt class="docutils literal"><span class="pre">sdl_mixer.fadeOutChannel(-1)</span></tt> for that instead.</p>
<p><tt class="docutils literal"><span class="pre">ms</span></tt> Milliseconds of time that the fade-out effect should take to go to silence, starting now.</p>
<p>The channels will be halted after the fade out is completed. Only channels that are playing are set to fade out, including paused channels. Any callback set by <tt class="docutils literal"><span class="pre">sdl_mixer.channelFinished()</span></tt> will be called when each channel finishes fading out.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the number of channels set to fade out.</p>


</dd>
<a id="fadeOutMusic,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#fadeOutMusic%2Ccint"><span class="Identifier">fadeOutMusic</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">ms</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_FadeOutMusic&quot;</span><span class="Other">,</span>
                                     <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Gradually fade out the music over <tt class="docutils literal"><span class="pre">ms</span></tt> milliseconds starting from now.</p>
<p><tt class="docutils literal"><span class="pre">ms</span></tt> Milliseconds of time that the fade-out effect should take to go to silence, starting now.</p>
<p>The music will be halted after the fade out is completed. Only when music is playing and not fading already are set to fade out, including paused channels.</p>
<p>Any callback set by <tt class="docutils literal"><span class="pre">sdl_mixer.hookMusicFinished()</span></tt> will be called when the music finishes fading out.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <tt class="docutils literal"><span class="pre">1</span></tt> on success, <tt class="docutils literal"><span class="pre">0</span></tt> on failure.</p>


</dd>
<a id="fadingMusic"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#fadingMusic"><span class="Identifier">fadingMusic</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Fading</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_FadingMusic&quot;</span><span class="Other">,</span>
                              <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Tells you if music is fading in, out, or not at all.</p>
<p>Does not tell you if the channel is playing anything, or paused, so you'd need to test that separately.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the fading status. Never returns an error.</p>


</dd>
<a id="fadingChannel,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#fadingChannel%2Ccint"><span class="Identifier">fadingChannel</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">which</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Fading</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_FadingChannel&quot;</span><span class="Other">,</span>
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Tells you if <tt class="docutils literal"><span class="pre">which</span></tt> channel is fading in, out, or not. Does not tell you if the channel is playing anything, or paused, so you'd need to test that separately.</p>
<p><tt class="docutils literal"><span class="pre">which</span></tt> Channel to get the fade activity status from. <tt class="docutils literal"><span class="pre">-1</span></tt> is not valid, and will probably crash the program.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the fading status. Never returns an error.</p>


</dd>
<a id="pause,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#pause%2Ccint"><span class="Identifier">pause</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">channel</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_Pause&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Pause <tt class="docutils literal"><span class="pre">channel</span></tt>, or all playing channels if <tt class="docutils literal"><span class="pre">-1</span></tt> is passed in. You may still halt a paused channel.</p>
<p><tt class="docutils literal"><span class="pre">channel</span></tt> Channel to pause on, or <tt class="docutils literal"><span class="pre">-1</span></tt> for all channels.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> Only channels which are actively playing will be paused.</p>


</dd>
<a id="resume,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#resume%2Ccint"><span class="Identifier">resume</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">channel</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_Resume&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Unpause <tt class="docutils literal"><span class="pre">channel</span></tt>, or all playing and paused channels if <tt class="docutils literal"><span class="pre">-1</span></tt> is passed in.</p>
<p><tt class="docutils literal"><span class="pre">channel</span></tt> Channel to resume playing, or <tt class="docutils literal"><span class="pre">-1</span></tt> for all channels.</p>


</dd>
<a id="paused,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#paused%2Ccint"><span class="Identifier">paused</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">channel</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_Paused&quot;</span><span class="Other">,</span>
                                    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Tells you if <tt class="docutils literal"><span class="pre">channel</span></tt> is paused, or not.</p>
<p><tt class="docutils literal"><span class="pre">channel</span></tt> Channel to test whether it is paused or not. <tt class="docutils literal"><span class="pre">-1</span></tt> will tell you how many channels are paused.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> Does not check if the channel has been halted after it was paused, which may seem a little weird.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <tt class="docutils literal"><span class="pre">0</span></tt> if the channel is not paused. Otherwise if you passed in <tt class="docutils literal"><span class="pre">-1</span></tt>, the number of paused channels is returned. If you passed in a specific channel, then <tt class="docutils literal"><span class="pre">1</span></tt> is returned if it is paused.</p>


</dd>
<a id="pauseMusic"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#pauseMusic"><span class="Identifier">pauseMusic</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_PauseMusic&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Pause the music playback. You may halt paused music.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> Music can only be paused if it is actively playing.</p>


</dd>
<a id="resumeMusic"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#resumeMusic"><span class="Identifier">resumeMusic</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_ResumeMusic&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

Unpause the music. This is safe to use on halted, paused, and already playing music.

</dd>
<a id="rewindMusic"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#rewindMusic"><span class="Identifier">rewindMusic</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_RewindMusic&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Rewind the music to the start. This is safe to use on halted, paused, and already playing music.</p>
<p>It is not useful to rewind the music immediately after starting playback, because it starts at the beginning by default.</p>
<p>This procedure only works for these streams: MOD, OGG, MP3, Native MIDI.</p>


</dd>
<a id="pausedMusic"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#pausedMusic"><span class="Identifier">pausedMusic</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_PausedMusic&quot;</span><span class="Other">,</span>
                            <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Tells you if music is paused, or not.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> Does not check if the music was been halted after it was paused, which may seem a little weird.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <tt class="docutils literal"><span class="pre">0</span></tt> if music is not paused. <tt class="docutils literal"><span class="pre">1</span></tt> if it is paused.</p>


</dd>
<a id="setMusicPosition,cdouble"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#setMusicPosition%2Ccdouble"><span class="Identifier">setMusicPosition</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">position</span><span class="Other">:</span> <span class="Identifier">cdouble</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_SetMusicPosition&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Set the current <tt class="docutils literal"><span class="pre">position</span></tt> in the music stream.</p>
<p><tt class="docutils literal"><span class="pre">position</span></tt> Posistion to play from.</p>
<p>The <tt class="docutils literal"><span class="pre">position</span></tt> takes different meanings for different music sources. It only works on the music sources listed below.</p>
<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">MOD</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">cdouble</span></tt> is cast to <tt class="docutils literal"><span class="pre">uint16</span></tt> and used for a pattern number in the module. Passing zero is similar to rewinding the song.</dd>
<dt><tt class="docutils literal"><span class="pre">OGG</span></tt></dt>
<dd>Jumps to position seconds from the beginning of the song.</dd>
<dt><tt class="docutils literal"><span class="pre">MP3</span></tt></dt>
<dd>Jumps to position seconds from the current position in the stream. So you may want to call <tt class="docutils literal"><span class="pre">sdl_mixer.rewindMusic()</span></tt> before this. Does not go in reverse. Negative values do nothing.</dd>
</dl>
<p>This procedurre is only implemented for MOD music formats (set pattern order number) and for OGG, FLAC, MP3_MAD, MPD_MPG and MODPLUG music (set position in seconds), at the moment.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <tt class="docutils literal"><span class="pre">0</span></tt> on success, or <tt class="docutils literal"><span class="pre">-1</span></tt> if the codec doesn't support this procedure.</p>


</dd>
<a id="playing,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#playing%2Ccint"><span class="Identifier">playing</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">channel</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_Playing&quot;</span><span class="Other">,</span>
                                     <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Tells you if <tt class="docutils literal"><span class="pre">channel</span></tt> is playing, or not.</p>
<p><tt class="docutils literal"><span class="pre">channel</span></tt> Channel to test whether it is playing or not. <tt class="docutils literal"><span class="pre">-1</span></tt> will tell you how many channels are playing.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> Does not check if the channel has been paused.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <tt class="docutils literal"><span class="pre">0</span></tt> if the channel is not playing. Otherwise if you passed in <tt class="docutils literal"><span class="pre">-1</span></tt>, the number of channels playing is returned. If you passed in a specific channel, then <tt class="docutils literal"><span class="pre">1</span></tt> is returned if it is playing.</p>


</dd>
<a id="playingMusic"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#playingMusic"><span class="Identifier">playingMusic</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_PlayingMusic&quot;</span><span class="Other">,</span>
                             <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Tells you if music is actively playing, or not.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> Does not check if the channel has been paused.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <tt class="docutils literal"><span class="pre">0</span></tt> if the music is not playing, or <tt class="docutils literal"><span class="pre">1</span></tt> if it is playing.</p>


</dd>
<a id="setMusicCMD,cstring"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#setMusicCMD%2Ccstring"><span class="Identifier">setMusicCMD</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">command</span><span class="Other">:</span> <span class="Identifier">cstring</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_SetMusicCMD&quot;</span><span class="Other">,</span>
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Stop music and set external music playback command.</p>
<p><tt class="docutils literal"><span class="pre">command</span></tt> System command to play the music. Should be a complete command, as if typed in to the command line, but it should expect the filename to be added as the last argument. <tt class="docutils literal"><span class="pre">nil</span></tt> will turn off using an external command for music, returning to the internal music playing functionality.</p>
<p>Setup a command line music player to use to play music. Any music playing will be halted.</p>
<p>The music file to play is set by calling <tt class="docutils literal"><span class="pre">sdl_mixer.loadMUS(filename)</span></tt>, and the filename is appended as the last argument on the commandline. This allows you to reuse the music command to play multiple files.</p>
<p>The command will be sent signals SIGTERM to halt, SIGSTOP to pause, and SIGCONT to resume. The command program should react correctly to those signals for it to function properly with SDL_Mixer.</p>
<p><tt class="docutils literal"><span class="pre">sdl_mixer.volumeMusic()</span></tt> has no effect when using an external music player, and <tt class="docutils literal"><span class="pre">sdl_mixer.getError()</span></tt> will have an error code set. You should set the music volume in the music player's command if the music player supports that. Looping music works, by calling the command again when the previous music player process has ended. Playing music through a command uses a forked process to execute the music command.</p>
<p>To use the internal music players set the command to <tt class="docutils literal"><span class="pre">nil</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> External music is not mixed by SDL_mixer, so no post-processing hooks will be for music.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> Playing music through an external command may not work if the sound driver does not support multiple openings of the audio device, since SDL_Mixer already has the audio device open for playing samples through channels.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> Commands are not totally portable, so be careful.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> <tt class="docutils literal"><span class="pre">0</span></tt> on success, or <tt class="docutils literal"><span class="pre">-1</span></tt> on any errors, such as running out of memory.</p>


</dd>
<a id="setSynchroValue,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#setSynchroValue%2Ccint"><span class="Identifier">setSynchroValue</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">value</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span>
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_SetSynchroValue&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

Synchro value is set by MikMod from modules while playing.

</dd>
<a id="getSynchroValue"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#getSynchroValue"><span class="Identifier">getSynchroValue</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_GetSynchroValue&quot;</span><span class="Other">,</span>
                                <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>



</dd>
<a id="setSoundFonts,cstring"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#setSoundFonts%2Ccstring"><span class="Identifier">setSoundFonts</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">paths</span><span class="Other">:</span> <span class="Identifier">cstring</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_SetSoundFonts&quot;</span><span class="Other">,</span>
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

Set SoundFonts paths to use by supported MIDI backends.

</dd>
<a id="getSoundFonts"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#getSoundFonts"><span class="Identifier">getSoundFonts</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cstring</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_GetSoundFonts&quot;</span><span class="Other">,</span>
                                 <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

Get SoundFonts paths to use by supported MIDI backends.

</dd>
<a id="eachSoundFont,proc(cstring,pointer),pointer"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#eachSoundFont%2Cproc%28cstring%2Cpointer%29%2Cpointer"><span class="Identifier">eachSoundFont</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">function</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">a2</span><span class="Other">:</span> <span class="Identifier">cstring</span><span class="Other">;</span> <span class="Identifier">a3</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span></span><span class="Other">.}</span></span><span class="Other">;</span>
                    <span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_EachSoundFont&quot;</span><span class="Other">,</span>
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

Iterate SoundFonts paths to use by supported MIDI backends.

</dd>
<a id="getChunk,cint"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#getChunk%2Ccint"><span class="Identifier">getChunk</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">channel</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Chunk</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_GetChunk&quot;</span><span class="Other">,</span>
                                       <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Get the most recent sample chunk pointer played on <tt class="docutils literal"><span class="pre">channel</span></tt>. This pointer may be currently playing, or just the last used.</p>
<p><tt class="docutils literal"><span class="pre">channel</span></tt> Channel to get the current <tt class="docutils literal"><span class="pre">sdl_mixer.Chunk</span></tt> playing. <tt class="docutils literal"><span class="pre">-1</span></tt> is not valid, but will not crash the program.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> The actual chunk may have been freed, so this pointer may not be valid anymore.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> pointer to the <tt class="docutils literal"><span class="pre">sdl_mixer.Chunk</span></tt>. <tt class="docutils literal"><span class="pre">nil</span></tt> is returned if the channel is not allocated, or if the channel has not played any samples yet.</p>


</dd>
<a id="closeAudio"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#closeAudio"><span class="Identifier">closeAudio</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;Mix_CloseAudio&quot;</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">SDL2_MIX_LIB</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

<p>Shutdown and cleanup the mixer API.</p>
<p>After calling this all audio is stopped, the device is closed, and the SDL_mixer procedures should not be used. You may, of course, use <tt class="docutils literal"><span class="pre">sdl_mixer.openAudio()</span></tt> to start the functionality again.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> This procedure doesn't do anything until you have called it the same number of times that you called <tt class="docutils literal"><span class="pre">sdl_mixer.openAudio()</span></tt>. You may use <tt class="docutils literal"><span class="pre">sdl_mixer.querySpec()</span></tt> to find out how many times <tt class="docutils literal"><span class="pre">sdl_mixer.closeAudio()</span></tt> needs to be called before the device is actually closed.</p>


</dd>

</dl></div>
<div class="section" id="18">
<h1><a class="toc-backref" href="#18">Templates</a></h1>
<dl class="item">
<a id="versionAtLeast.t,untyped,untyped,untyped"></a>
<dt><pre><span class="Keyword">template</span> <a href="#versionAtLeast.t%2Cuntyped%2Cuntyped%2Cuntyped"><span class="Identifier">versionAtLeast</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">x</span><span class="Other">,</span> <span class="Identifier">y</span><span class="Other">,</span> <span class="Identifier">z</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>


This template will evaluate to true if compiled with SDL_mixer at least X.Y.Z.

</dd>
<a id="loadWAV_RW.t,ptr.RWops,bool"></a>
<dt><pre><span class="Keyword">template</span> <a href="#loadWAV_RW.t%2Cptr.RWops%2Cbool"><span class="Identifier">loadWAV_RW</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">src</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">RWops</span><span class="Other">;</span> <span class="Identifier">freesrc</span><span class="Other">:</span> <span class="Identifier">bool</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Chunk</span></pre></dt>
<dd>



</dd>
<a id="loadWAV.t,untyped"></a>
<dt><pre><span class="Keyword">template</span> <a href="#loadWAV.t%2Cuntyped"><span class="Identifier">loadWAV</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">file</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>

<p>
Load file for use as a sample. This is actually <tt class="docutils literal"><span class="pre">sdl_mixer.loadWAV_RW(sdl.rwFromFile(file, &quot;rb&quot;), 1)</span></tt>. This can load WAVE, AIFF, RIFF, OGG, and VOC files.</p>
<p><tt class="docutils literal"><span class="pre">file</span></tt> File name to load sample from.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> You must call <tt class="docutils literal"><span class="pre">sdl.openAudio()</span></tt> before this. It must know the output characteristics so it can convert the sample for playback, it does this conversion at load time.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> a pointer to the sample as a <tt class="docutils literal"><span class="pre">sdl_mixer.Chunk</span></tt>. <tt class="docutils literal"><span class="pre">nil</span></tt> is returned on errors.</p>


</dd>
<a id="loadMUS_RW.t,ptr.RWops,bool"></a>
<dt><pre><span class="Keyword">template</span> <a href="#loadMUS_RW.t%2Cptr.RWops%2Cbool"><span class="Identifier">loadMUS_RW</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">src</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">RWops</span><span class="Other">;</span> <span class="Identifier">freesrc</span><span class="Other">:</span> <span class="Identifier">bool</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Music</span></pre></dt>
<dd>



</dd>
<a id="loadMUSType_RW.t,ptr.RWops,MusicType,bool"></a>
<dt><pre><span class="Keyword">template</span> <a href="#loadMUSType_RW.t%2Cptr.RWops%2CMusicType%2Cbool"><span class="Identifier">loadMUSType_RW</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">src</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">RWops</span><span class="Other">;</span> <span class="Identifier">kind</span><span class="Other">:</span> <span class="Identifier">MusicType</span><span class="Other">;</span> <span class="Identifier">freesrc</span><span class="Other">:</span> <span class="Identifier">bool</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Music</span></pre></dt>
<dd>



</dd>
<a id="playChannel.t,untyped,untyped,untyped"></a>
<dt><pre><span class="Keyword">template</span> <a href="#playChannel.t%2Cuntyped%2Cuntyped%2Cuntyped"><span class="Identifier">playChannel</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">channel</span><span class="Other">,</span> <span class="Identifier">chunk</span><span class="Other">,</span> <span class="Identifier">loops</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>

<p>
Play chunk on channel, or if channel is <tt class="docutils literal"><span class="pre">-1</span></tt>, pick the first free unreserved channel.</p>
<p><tt class="docutils literal"><span class="pre">channel</span></tt> Channel to play on, or <tt class="docutils literal"><span class="pre">-1</span></tt> for the first free unreserved channel.</p>
<p><tt class="docutils literal"><span class="pre">chunk</span></tt> Sample to play.</p>
<p><tt class="docutils literal"><span class="pre">loops</span></tt> Number of loops, <tt class="docutils literal"><span class="pre">-1</span></tt> is infinite loops. Passing <tt class="docutils literal"><span class="pre">1</span></tt> here plays the sample twice (1 loop).</p>
<p>The sample will play for <tt class="docutils literal"><span class="pre">loops</span></tt> + 1 number of times, unless stopped by halt, or fade out, or setting a new expiration time of less time than it would have originally taken to play the loops, or closing the mixer.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> this just calls <tt class="docutils literal"><span class="pre">sdl_mixer.playChannelTimed()</span></tt> with ticks set to <tt class="docutils literal"><span class="pre">-1</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the channel the sample is played on. On any errors, <tt class="docutils literal"><span class="pre">-1</span></tt> is returned.</p>


</dd>
<a id="fadeInChannel.t,untyped,untyped,untyped,untyped"></a>
<dt><pre><span class="Keyword">template</span> <a href="#fadeInChannel.t%2Cuntyped%2Cuntyped%2Cuntyped%2Cuntyped"><span class="Identifier">fadeInChannel</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">channel</span><span class="Other">,</span> <span class="Identifier">chunk</span><span class="Other">,</span> <span class="Identifier">loops</span><span class="Other">,</span> <span class="Identifier">ms</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>

<p>
Play <tt class="docutils literal"><span class="pre">chunk</span></tt> on <tt class="docutils literal"><span class="pre">channel</span></tt>, or if <tt class="docutils literal"><span class="pre">channel</span></tt> is <tt class="docutils literal"><span class="pre">-1</span></tt>, pick the first free unreserved channel.</p>
<p><tt class="docutils literal"><span class="pre">channel</span></tt> Channel to play on, or <tt class="docutils literal"><span class="pre">-1</span></tt> for the first free unreserved channel.</p>
<p><tt class="docutils literal"><span class="pre">chunk</span></tt> Sample to play.</p>
<p><tt class="docutils literal"><span class="pre">loops</span></tt> Number of loops, <tt class="docutils literal"><span class="pre">-1</span></tt> is infinite loops. Passing <tt class="docutils literal"><span class="pre">1</span></tt> here plays the sample twice (1 loop).</p>
<p><tt class="docutils literal"><span class="pre">ms</span></tt> Milliseconds of time that the fade-in effect should take to go from silence to full volume.</p>
<p>The channel volume starts at <tt class="docutils literal"><span class="pre">0</span></tt> and fades up to full volume over <tt class="docutils literal"><span class="pre">ms</span></tt> milliseconds of time. The sample may end before the fade-in is complete if it is too short or doesn't have enough loops. The sample will play for <tt class="docutils literal"><span class="pre">loops</span></tt> + 1 number of times, unless stopped by halt, or fade out, or setting a new expiration time of less time than it would have originally taken to play the loops, or closing the mixer.</p>
<p><tt class="docutils literal"><span class="pre">Note:</span></tt> this just calls <tt class="docutils literal"><span class="pre">sdl_mixer.fadeInChannelTimed()</span></tt> with ticks set to <tt class="docutils literal"><span class="pre">-1</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">Return</span></tt> the channel the sample is played on. On any errors, <tt class="docutils literal"><span class="pre">-1</span></tt> is returned.</p>


</dd>
<a id="setError.t,untyped"></a>
<dt><pre><span class="Keyword">template</span> <a href="#setError.t%2Cuntyped"><span class="Identifier">setError</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">fmt</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span></pre></dt>
<dd>



</dd>
<a id="getError.t"></a>
<dt><pre><span class="Keyword">template</span> <a href="#getError.t"><span class="Identifier">getError</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cstring</span></pre></dt>
<dd>



</dd>
<a id="clearError.t"></a>
<dt><pre><span class="Keyword">template</span> <a href="#clearError.t"><span class="Identifier">clearError</span></a><span class="Operator">*</span><span class="Other">(</span><span class="Other">)</span></pre></dt>
<dd>



</dd>

</dl></div>

  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small style="color: var(--hint);">Made with Nim. Generated: 2020-12-27 16:22:18 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
